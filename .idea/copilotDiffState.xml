<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;kotlin-kapt&quot;)&#10;    id(&quot;dagger.hilt.android.plugin&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.permitely&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.permitely&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Existing dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Hilt for Dependency Injection&#10;    implementation(&quot;com.google.dagger:hilt-android:2.48&quot;)&#10;    kapt(&quot;com.google.dagger:hilt-compiler:2.48&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    // Navigation Compose&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.5&quot;)&#10;&#10;    // ViewModel Compose&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-runtime-compose:2.7.0&quot;)&#10;&#10;    // Coroutines&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;&#10;    // Material Icons Extended&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.4&quot;)&#10;&#10;    // CameraX Dependencies&#10;    implementation(&quot;androidx.camera:camera-core:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-camera2:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-lifecycle:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-video:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-view:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-extensions:1.3.1&quot;)&#10;&#10;    // Networking Dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;&#10;    // JSON Serialization&#10;    implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)&#10;&#10;    // DataStore for token storage&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // Test dependencies&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;kotlin-kapt&quot;)&#10;    id(&quot;dagger.hilt.android.plugin&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.permitely&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.permitely&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        &#10;        // Default base URL (can be overridden by build variants)&#10;        buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://permitly-production.up.railway.app/\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        debug {&#10;            isDebuggable = true&#10;            applicationIdSuffix = &quot;.debug&quot;&#10;            versionNameSuffix = &quot;-debug&quot;&#10;            // Development/Staging URL&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://permitly-staging.up.railway.app/\&quot;&quot;)&#10;        }&#10;        &#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            // Production URL&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://permitly-production.up.railway.app/\&quot;&quot;)&#10;        }&#10;    }&#10;    &#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true // Enable BuildConfig generation&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Existing dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Hilt for Dependency Injection&#10;    implementation(&quot;com.google.dagger:hilt-android:2.48&quot;)&#10;    kapt(&quot;com.google.dagger:hilt-compiler:2.48&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    // Navigation Compose&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.5&quot;)&#10;&#10;    // ViewModel Compose&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-runtime-compose:2.7.0&quot;)&#10;&#10;    // Coroutines&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;&#10;    // Material Icons Extended&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.4&quot;)&#10;&#10;    // CameraX Dependencies&#10;    implementation(&quot;androidx.camera:camera-core:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-camera2:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-lifecycle:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-video:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-view:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-extensions:1.3.1&quot;)&#10;&#10;    // Networking Dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;&#10;    // JSON Serialization&#10;    implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)&#10;&#10;    // DataStore for token storage&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // Test dependencies&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/models/AuthModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/models/AuthModels.kt" />
              <option name="originalContent" value="package com.example.permitely.data.models&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;// ============================================================================&#10;// Authentication Data Models for Permitly - Visitor Management System&#10;// ============================================================================&#10;// Updated to match backend API structure exactly&#10;&#10;/**&#10; * Login request matching backend /api/auth/signin endpoint&#10; */&#10;data class LoginRequest(&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;/**&#10; * Signup request matching backend /api/auth/signup endpoint&#10; */&#10;data class SignupRequest(&#10;    val name: String,&#10;    val email: String,&#10;    val password: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    val role: String // &quot;admin&quot;, &quot;host&quot;, &quot;guard&quot;&#10;)&#10;&#10;/**&#10; * Base API response structure from backend&#10; */&#10;data class ApiResponse&lt;T&gt;(&#10;    @SerializedName(&quot;status&quot;) val success: String,&#10;    val message: String? = null,&#10;    val data: T? = null&#10;) {&#10;    // Helper property to check if response is successful&#10;    val isSuccess: Boolean get() = success == &quot;success&quot;&#10;}&#10;&#10;/**&#10; * Token refresh request&#10; */&#10;data class RefreshTokenRequest(&#10;    val refreshToken: String&#10;)&#10;&#10;/**&#10; * Logout request&#10; */&#10;data class LogoutRequest(&#10;    val refreshToken: String&#10;)&#10;&#10;/**&#10; * Login response data structure from backend&#10; */&#10;data class LoginResponseData(&#10;    val user: UserData,&#10;    val tokens: TokenData&#10;)&#10;&#10;/**&#10; * Signup response data structure from backend&#10; */&#10;data class SignupResponseData(&#10;    val user: UserData,&#10;    val tokens: TokenData&#10;)&#10;&#10;/**&#10; * Token refresh response data structure&#10; */&#10;data class TokenResponseData(&#10;    val tokens: TokenData&#10;)&#10;&#10;/**&#10; * User data from backend response&#10; */&#10;data class UserData(&#10;    val id: Int,  // Changed from String to Int to match backend&#10;    val name: String,&#10;    val email: String,&#10;    val role: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String&#10;)&#10;&#10;/**&#10; * Token data structure&#10; */&#10;data class TokenData(&#10;    val accessToken: String,&#10;    val refreshToken: String&#10;)&#10;&#10;/**&#10; * User data structure (when returned from backend)&#10; */&#10;data class User(&#10;    val id: Int,  // Changed from String to Int to match backend&#10;    val name: String,&#10;    val email: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    val role: String, // &quot;admin&quot;, &quot;host&quot;, &quot;guard&quot;&#10;    val isVerified: Boolean = false&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.permitely.data.models&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;// ============================================================================&#10;// Authentication Data Models for Permitly - Visitor Management System&#10;// ============================================================================&#10;// Updated to match backend API structure exactly&#10;&#10;/**&#10; * Login request matching backend /api/auth/signin endpoint&#10; */&#10;data class LoginRequest(&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;/**&#10; * Signup request matching backend /api/auth/signup endpoint&#10; */&#10;data class SignupRequest(&#10;    val name: String,&#10;    val email: String,&#10;    val password: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    val role: String // &quot;admin&quot;, &quot;host&quot;, &quot;guard&quot;&#10;)&#10;&#10;/**&#10; * Base API response structure from backend (for login/auth APIs)&#10; */&#10;data class ApiResponse&lt;T&gt;(&#10;    val success: Boolean,  // Login API uses &quot;success&quot;: true/false&#10;    val message: String? = null,&#10;    val data: T? = null&#10;)&#10;&#10;/**&#10; * Token refresh request&#10; */&#10;data class RefreshTokenRequest(&#10;    val refreshToken: String&#10;)&#10;&#10;/**&#10; * Logout request&#10; */&#10;data class LogoutRequest(&#10;    val refreshToken: String&#10;)&#10;&#10;/**&#10; * Login response data structure from backend&#10; */&#10;data class LoginResponseData(&#10;    val user: UserData,&#10;    val tokens: TokenData&#10;)&#10;&#10;/**&#10; * Signup response data structure from backend&#10; */&#10;data class SignupResponseData(&#10;    val user: UserData,&#10;    val tokens: TokenData&#10;)&#10;&#10;/**&#10; * Token refresh response data structure&#10; */&#10;data class TokenResponseData(&#10;    val tokens: TokenData&#10;)&#10;&#10;/**&#10; * User data from backend response&#10; */&#10;data class UserData(&#10;    val id: Int,  // Changed from String to Int to match backend&#10;    val name: String,&#10;    val email: String,&#10;    val role: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String&#10;)&#10;&#10;/**&#10; * Token data structure&#10; */&#10;data class TokenData(&#10;    val accessToken: String,&#10;    val refreshToken: String&#10;)&#10;&#10;/**&#10; * User data structure (when returned from backend)&#10; */&#10;data class User(&#10;    val id: Int,  // Changed from String to Int to match backend&#10;    val name: String,&#10;    val email: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    val role: String, // &quot;admin&quot;, &quot;host&quot;, &quot;guard&quot;&#10;    val isVerified: Boolean = false&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/models/DashboardModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/models/DashboardModels.kt" />
              <option name="originalContent" value="package com.example.permitely.data.models&#10;&#10;/**&#10; * Dashboard statistics response data model&#10; * Matches the API response from /api/user/dashboard/stats&#10; */&#10;data class DashboardStatsResponse(&#10;    val success: Boolean,&#10;    val data: DashboardStats? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Dashboard statistics data&#10; */&#10;data class DashboardStats(&#10;    val totalVisitors: Int,&#10;    val approved: Int,&#10;    val pending: Int,&#10;    val rejected: Int,&#10;    val expired: Int&#10;)&#10;&#10;/**&#10; * UI state for dashboard stats&#10; */&#10;data class DashboardStatsUiState(&#10;    val totalVisitors: Int = 0,&#10;    val approved: Int = 0,&#10;    val pending: Int = 0,&#10;    val rejected: Int = 0,&#10;    val expired: Int = 0,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val userName: String = &quot;User&quot;,&#10;    val userEmail: String = &quot;&quot;,&#10;    val userRole: String = &quot;&quot;&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.permitely.data.models&#10;&#10;/**&#10; * Dashboard statistics response data model&#10; * Matches the API response from /api/user/dashboard/stats&#10; */&#10;data class DashboardStatsResponse(&#10;    val success: Boolean,&#10;    val data: DashboardStats? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Dashboard statistics data&#10; */&#10;data class DashboardStats(&#10;    val totalVisitors: Int,&#10;    val approved: Int,&#10;    val pending: Int,&#10;    val rejected: Int,&#10;    val expired: Int&#10;)&#10;&#10;/**&#10; * UI state for dashboard stats&#10; */&#10;data class DashboardStatsUiState(&#10;    val totalVisitors: Int = 0,&#10;    val approved: Int = 0,&#10;    val pending: Int = 0,&#10;    val rejected: Int = 0,&#10;    val expired: Int = 0,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val userName: String = &quot;User&quot;,&#10;    val userEmail: String = &quot;&quot;,&#10;    val userRole: String = &quot;&quot;&#10;)&#10;&#10;/**&#10; * Recent visitors API response data model&#10; * Matches the API response from /api/users/recent-visitors&#10; */&#10;data class RecentVisitorsResponse(&#10;    val success: Boolean,&#10;    val data: List&lt;RecentVisitor&gt;? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Recent visitor data model&#10; */&#10;data class RecentVisitor(&#10;    val visitor_id: Int,&#10;    val name: String,&#10;    val phone_number: String,&#10;    val email: String,&#10;    val purpose_of_visit: String,&#10;    val host_id: Int,&#10;    val created_by_guard_id: Int?,&#10;    val status: String,&#10;    val entry_time: String?,&#10;    val exit_time: String?,&#10;    val created_at: String,&#10;    val updated_at: String,&#10;    val passes: List&lt;VisitorPass&gt;,&#10;    val host: HostInfo&#10;)&#10;&#10;/**&#10; * Visitor pass information&#10; */&#10;data class VisitorPass(&#10;    val pass_id: Int,&#10;    val visitor_id: Int,&#10;    val qr_code_data: String,&#10;    val qr_code_url: String,&#10;    val created_at: String,&#10;    val expiry_time: String,&#10;    val approved_at: String?,&#10;    val approved_by: String?&#10;)&#10;&#10;/**&#10; * Host information for visitor&#10; */&#10;data class HostInfo(&#10;    val name: String,&#10;    val email: String,&#10;    val phone_number: String&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/models/VisitorModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/models/VisitorModels.kt" />
              <option name="originalContent" value="package com.example.permitely.data.models&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;/**&#10; * Create visitor request model&#10; */&#10;data class CreateVisitorRequest(&#10;    val name: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    val email: String,&#10;    @SerializedName(&quot;purpose_of_visit&quot;) val purposeOfVisit: String,&#10;    @SerializedName(&quot;expiry_time&quot;) val expiryTime: String? = null // Optional ISO string format&#10;)&#10;&#10;/**&#10; * Visitor data model from API response - updated to match actual API structure&#10; */&#10;data class VisitorData(&#10;    @SerializedName(&quot;visitor_id&quot;) val visitorId: Int,&#10;    val name: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    val email: String,&#10;    @SerializedName(&quot;purpose_of_visit&quot;) val purposeOfVisit: String,&#10;    val status: String, // PENDING, APPROVED, REJECTED, EXPIRED&#10;    @SerializedName(&quot;entry_time&quot;) val entryTime: String?,&#10;    @SerializedName(&quot;exit_time&quot;) val exitTime: String?,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    val passes: List&lt;PassData&gt; = emptyList() // Array of passes, newest first&#10;)&#10;&#10;/**&#10; * Pass data model from API response - updated structure&#10; */&#10;data class PassData(&#10;    @SerializedName(&quot;pass_id&quot;) val passId: Int,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    @SerializedName(&quot;expiry_time&quot;) val expiryTime: String,&#10;    @SerializedName(&quot;approved_at&quot;) val approvedAt: String,&#10;    @SerializedName(&quot;qr_code_data&quot;) val qrCodeData: String // This is the QR code URL&#10;)&#10;&#10;/**&#10; * Create visitor response data&#10; */&#10;data class CreateVisitorResponseData(&#10;    val visitor: VisitorData,&#10;    val pass: PassData?, // Only present if expiry_time was provided&#10;    val message: String&#10;)&#10;&#10;/**&#10; * Create visitor API response wrapper&#10; */&#10;data class CreateVisitorResponse(&#10;    val status: String,&#10;    val data: CreateVisitorResponseData? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get all visitors API response wrapper&#10; */&#10;data class GetAllVisitorsResponse(&#10;    val status: String,&#10;    val results: Int? = null,&#10;    val data: GetAllVisitorsData? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get all visitors response data&#10; */&#10;data class GetAllVisitorsData(&#10;    val visitors: List&lt;VisitorData&gt;&#10;)&#10;&#10;/**&#10; * Get visitor by ID API response wrapper&#10; */&#10;data class GetVisitorByIdResponse(&#10;    val status: String,&#10;    val data: GetVisitorByIdData? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get visitor by ID response data - updated to match API structure&#10; */&#10;data class GetVisitorByIdData(&#10;    val visitor: VisitorData // Visitor already contains passes array&#10;)&#10;&#10;/**&#10; * Get recent visitors API response wrapper&#10; */&#10;data class GetRecentVisitorsResponse(&#10;    val success: Boolean,&#10;    val data: List&lt;VisitorData&gt;? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get notifications API response wrapper&#10; */&#10;data class GetNotificationsResponse(&#10;    val status: String,&#10;    val results: Int? = null,&#10;    val data: GetNotificationsData? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get notifications response data&#10; */&#10;data class GetNotificationsData(&#10;    val notifications: List&lt;NotificationData&gt;&#10;)&#10;&#10;/**&#10; * Notification data model from API response&#10; * Only includes fields needed for UI: name, created_at, status, content&#10; */&#10;data class NotificationData(&#10;    @SerializedName(&quot;notification_id&quot;) val notificationId: Int,&#10;    val content: String,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    val visitor: VisitorNotificationData?&#10;)&#10;&#10;/**&#10; * Visitor data in notification (simplified)&#10; */&#10;data class VisitorNotificationData(&#10;    val name: String,&#10;    val status: String // PENDING, APPROVED, REJECTED, EXPIRED&#10;)&#10;&#10;/**&#10; * Pass scanning API response data structure&#10; */&#10;data class PassScanResponseData(&#10;    val pass: PassScanData,&#10;    val visitor: VisitorScanData&#10;)&#10;&#10;/**&#10; * Pass data from scan API response&#10; */&#10;data class PassScanData(&#10;    @SerializedName(&quot;pass_id&quot;) val passId: Int,&#10;    @SerializedName(&quot;visitor_id&quot;) val visitorId: Int,&#10;    @SerializedName(&quot;qr_code_data&quot;) val qrCodeData: String,&#10;    @SerializedName(&quot;qr_code_url&quot;) val qrCodeUrl: String,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    @SerializedName(&quot;expiry_time&quot;) val expiryTime: String,&#10;    @SerializedName(&quot;approved_at&quot;) val approvedAt: String?,&#10;    @SerializedName(&quot;approved_by&quot;) val approvedBy: Int?&#10;)&#10;&#10;/**&#10; * Visitor data from scan API response&#10; */&#10;data class VisitorScanData(&#10;    @SerializedName(&quot;visitor_id&quot;) val visitorId: Int,&#10;    val name: String,&#10;    val email: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    @SerializedName(&quot;purpose_of_visit&quot;) val purposeOfVisit: String,&#10;    @SerializedName(&quot;host_id&quot;) val hostId: Int,&#10;    @SerializedName(&quot;created_by_guard_id&quot;) val createdByGuardId: Int?,&#10;    val status: String, // PENDING, APPROVED, REJECTED, EXPIRED&#10;    @SerializedName(&quot;entry_time&quot;) val entryTime: String?,&#10;    @SerializedName(&quot;exit_time&quot;) val exitTime: String?,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    @SerializedName(&quot;updated_at&quot;) val updatedAt: String&#10;)&#10;&#10;/**&#10; * UI state for pass scanning result&#10; */&#10;data class PassScanResult(&#10;    val isSuccess: Boolean,&#10;    val pass: PassScanData? = null,&#10;    val visitor: VisitorScanData? = null,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;/**&#10; * Guard today stats data from API response&#10; */&#10;data class GuardTodayStatsData(&#10;    val approvedVisitors: Int,    // Today's approved visitors (entered)&#10;    val pendingVisitors: Int,     // Today's pending visitors (waiting)&#10;    val expiredVisitors: Int,     // Today's expired visitors&#10;    val rejectedVisitors: Int,    // Today's rejected visitors&#10;    val totalVisitors: Int,       // Sum of all above (total for today)&#10;    val date: String              // Date for these stats (2025-08-11)&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.permitely.data.models&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;/**&#10; * Create visitor request model&#10; */&#10;data class CreateVisitorRequest(&#10;    val name: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    val email: String,&#10;    @SerializedName(&quot;purpose_of_visit&quot;) val purposeOfVisit: String,&#10;    @SerializedName(&quot;expiry_time&quot;) val expiryTime: String? = null // Optional ISO string format&#10;)&#10;&#10;/**&#10; * Visitor data model from API response - updated to match actual API structure&#10; */&#10;data class VisitorData(&#10;    @SerializedName(&quot;visitor_id&quot;) val visitorId: Int,&#10;    val name: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    val email: String,&#10;    @SerializedName(&quot;purpose_of_visit&quot;) val purposeOfVisit: String,&#10;    val status: String, // PENDING, APPROVED, REJECTED, EXPIRED&#10;    @SerializedName(&quot;entry_time&quot;) val entryTime: String?,&#10;    @SerializedName(&quot;exit_time&quot;) val exitTime: String?,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    val passes: List&lt;PassData&gt; = emptyList() // Array of passes, newest first&#10;)&#10;&#10;/**&#10; * Pass data model from API response - updated structure&#10; */&#10;data class PassData(&#10;    @SerializedName(&quot;pass_id&quot;) val passId: Int,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    @SerializedName(&quot;expiry_time&quot;) val expiryTime: String,&#10;    @SerializedName(&quot;approved_at&quot;) val approvedAt: String,&#10;    @SerializedName(&quot;qr_code_data&quot;) val qrCodeData: String // This is the QR code URL&#10;)&#10;&#10;/**&#10; * Create visitor response data&#10; */&#10;data class CreateVisitorResponseData(&#10;    val visitor: VisitorData,&#10;    val pass: PassData?, // Only present if expiry_time was provided&#10;    val message: String&#10;)&#10;&#10;/**&#10; * Create visitor API response wrapper&#10; */&#10;data class CreateVisitorResponse(&#10;    val status: String,&#10;    val data: CreateVisitorResponseData? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get all visitors API response wrapper&#10; */&#10;data class GetAllVisitorsResponse(&#10;    val status: String,&#10;    val results: Int? = null,&#10;    val data: GetAllVisitorsData? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get all visitors response data&#10; */&#10;data class GetAllVisitorsData(&#10;    val visitors: List&lt;VisitorData&gt;&#10;)&#10;&#10;/**&#10; * Get visitor by ID API response wrapper&#10; */&#10;data class GetVisitorByIdResponse(&#10;    val status: String,&#10;    val data: GetVisitorByIdData? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get visitor by ID response data - updated to match API structure&#10; */&#10;data class GetVisitorByIdData(&#10;    val visitor: VisitorData // Visitor already contains passes array&#10;)&#10;&#10;/**&#10; * Get recent visitors API response wrapper&#10; */&#10;data class GetRecentVisitorsResponse(&#10;    val success: Boolean,&#10;    val data: List&lt;VisitorData&gt;? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get notifications API response wrapper&#10; */&#10;data class GetNotificationsResponse(&#10;    val status: String,&#10;    val results: Int? = null,&#10;    val data: GetNotificationsData? = null,&#10;    val message: String? = null&#10;)&#10;&#10;/**&#10; * Get notifications response data&#10; */&#10;data class GetNotificationsData(&#10;    val notifications: List&lt;NotificationData&gt;&#10;)&#10;&#10;/**&#10; * Notification data model from API response&#10; * Only includes fields needed for UI: name, created_at, status, content&#10; */&#10;data class NotificationData(&#10;    @SerializedName(&quot;notification_id&quot;) val notificationId: Int,&#10;    val content: String,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    val visitor: VisitorNotificationData?&#10;)&#10;&#10;/**&#10; * Visitor data in notification (simplified)&#10; */&#10;data class VisitorNotificationData(&#10;    val name: String,&#10;    val status: String // PENDING, APPROVED, REJECTED, EXPIRED&#10;)&#10;&#10;/**&#10; * Pass scanning API response data structure&#10; */&#10;data class PassScanResponseData(&#10;    val pass: PassScanData,&#10;    val visitor: VisitorScanData&#10;)&#10;&#10;/**&#10; * Pass data from scan API response&#10; */&#10;data class PassScanData(&#10;    @SerializedName(&quot;pass_id&quot;) val passId: Int,&#10;    @SerializedName(&quot;visitor_id&quot;) val visitorId: Int,&#10;    @SerializedName(&quot;qr_code_data&quot;) val qrCodeData: String,&#10;    @SerializedName(&quot;qr_code_url&quot;) val qrCodeUrl: String,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    @SerializedName(&quot;expiry_time&quot;) val expiryTime: String,&#10;    @SerializedName(&quot;approved_at&quot;) val approvedAt: String?,&#10;    @SerializedName(&quot;approved_by&quot;) val approvedBy: Int?&#10;)&#10;&#10;/**&#10; * Visitor data from scan API response&#10; */&#10;data class VisitorScanData(&#10;    @SerializedName(&quot;visitor_id&quot;) val visitorId: Int,&#10;    val name: String,&#10;    val email: String,&#10;    @SerializedName(&quot;phone_number&quot;) val phoneNumber: String,&#10;    @SerializedName(&quot;purpose_of_visit&quot;) val purposeOfVisit: String,&#10;    @SerializedName(&quot;host_id&quot;) val hostId: Int,&#10;    @SerializedName(&quot;created_by_guard_id&quot;) val createdByGuardId: Int?,&#10;    val status: String, // PENDING, APPROVED, REJECTED, EXPIRED&#10;    @SerializedName(&quot;entry_time&quot;) val entryTime: String?,&#10;    @SerializedName(&quot;exit_time&quot;) val exitTime: String?,&#10;    @SerializedName(&quot;created_at&quot;) val createdAt: String,&#10;    @SerializedName(&quot;updated_at&quot;) val updatedAt: String&#10;)&#10;&#10;/**&#10; * UI state for pass scanning result&#10; */&#10;data class PassScanResult(&#10;    val isSuccess: Boolean,&#10;    val pass: PassScanData? = null,&#10;    val visitor: VisitorScanData? = null,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;/**&#10; * Guard today stats API response data structure&#10; * Updated to match actual backend response: {&quot;status&quot;:&quot;success&quot;,&quot;data&quot;:{&quot;stats&quot;:{...}}}&#10; */&#10;data class GuardTodayStatsResponse(&#10;    val stats: GuardTodayStatsData&#10;)&#10;&#10;/**&#10; * Guard today stats data from API response&#10; */&#10;data class GuardTodayStatsData(&#10;    val approvedVisitors: Int,    // Today's approved visitors (entered)&#10;    val pendingVisitors: Int,     // Today's pending visitors (waiting)&#10;    val expiredVisitors: Int,     // Today's expired visitors&#10;    val rejectedVisitors: Int,    // Today's rejected visitors&#10;    val totalVisitors: Int,       // Sum of all above (total for today)&#10;    val date: String              // Date for these stats (2025-08-11)&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/network/DashboardApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/network/DashboardApiService.kt" />
              <option name="originalContent" value="package com.example.permitely.data.network&#10;&#10;import com.example.permitely.data.models.DashboardStatsResponse&#10;import retrofit2.Response&#10;import retrofit2.http.GET&#10;import retrofit2.http.Header&#10;&#10;/**&#10; * Retrofit API service interface for dashboard endpoints&#10; */&#10;interface DashboardApiService {&#10;&#10;    /**&#10;     * Get dashboard statistics&#10;     * GET /api/user/dashboard/stats&#10;     */&#10;    @GET(&quot;api/users/dashboard/stats&quot;)&#10;    suspend fun getDashboardStats(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;DashboardStatsResponse&gt;&#10;&#10;    @GET(&quot;api/users/recent-visitors&quot;)&#10;    suspend fun getRecentVisitors(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;DashboardStatsResponse&gt;&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.data.network&#10;&#10;import com.example.permitely.data.models.DashboardStatsResponse&#10;import com.example.permitely.data.models.RecentVisitorsResponse&#10;import retrofit2.Response&#10;import retrofit2.http.GET&#10;import retrofit2.http.Header&#10;&#10;/**&#10; * Retrofit API service interface for dashboard endpoints&#10; */&#10;interface DashboardApiService {&#10;&#10;    /**&#10;     * Get dashboard statistics&#10;     * GET /api/user/dashboard/stats&#10;     */&#10;    @GET(&quot;api/users/dashboard/stats&quot;)&#10;    suspend fun getDashboardStats(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;DashboardStatsResponse&gt;&#10;&#10;    /**&#10;     * Get recent visitors for the host&#10;     * GET /api/users/recent-visitors&#10;     */&#10;    @GET(&quot;api/users/recent-visitors&quot;)&#10;    suspend fun getRecentVisitors(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;RecentVisitorsResponse&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/network/GuardApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/network/GuardApiService.kt" />
              <option name="originalContent" value="package com.example.permitely.data.network&#10;&#10;import com.example.permitely.data.models.*&#10;import retrofit2.Response&#10;import retrofit2.http.GET&#10;import retrofit2.http.Header&#10;import retrofit2.http.POST&#10;import retrofit2.http.Path&#10;&#10;/**&#10; * Retrofit API service interface for guard endpoints&#10; * Base URL: https://permitly-production.up.railway.app&#10; */&#10;interface GuardApiService {&#10;&#10;    /**&#10;     * Scan visitor pass endpoint&#10;     * POST /api/guard/scan/{passId}&#10;     */&#10;    @POST(&quot;api/guard/scan/{passId}&quot;)&#10;    suspend fun scanPass(&#10;        @Path(&quot;passId&quot;) passId: Int,&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;ApiResponse&lt;PassScanResponseData&gt;&gt;&#10;&#10;    /**&#10;     * Get today's guard statistics&#10;     * GET /api/guard/stats/today&#10;     */&#10;    @GET(&quot;api/guard/stats/today&quot;)&#10;    suspend fun getTodayStats(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;ApiResponse&lt;GuardTodayStatsData&gt;&gt;&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.data.network&#10;&#10;import com.example.permitely.data.models.*&#10;import retrofit2.Response&#10;import retrofit2.http.GET&#10;import retrofit2.http.Header&#10;import retrofit2.http.POST&#10;import retrofit2.http.Path&#10;&#10;/**&#10; * Retrofit API service interface for guard endpoints&#10; * Base URL: https://permitly-production.up.railway.app&#10; */&#10;interface GuardApiService {&#10;&#10;    /**&#10;     * Scan visitor pass endpoint&#10;     * POST /api/guard/scan/{passId}&#10;     */&#10;    @POST(&quot;api/guard/scan/{passId}&quot;)&#10;    suspend fun scanPass(&#10;        @Path(&quot;passId&quot;) passId: Int,&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;ApiResponse&lt;PassScanResponseData&gt;&gt;&#10;&#10;    /**&#10;     * Get today's guard statistics&#10;     * GET /api/guard/stats/today&#10;     */&#10;    @GET(&quot;api/guard/stats/today&quot;)&#10;    suspend fun getTodayStats(&#10;        @Header(&quot;Authorization&quot;) token: String&#10;    ): Response&lt;ApiResponse&lt;GuardTodayStatsResponse&gt;&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/repository/AuthRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/repository/AuthRepository.kt" />
              <option name="originalContent" value="package com.example.permitely.data.repository&#10;&#10;import com.example.permitely.data.models.*&#10;import com.example.permitely.data.network.AuthApiService&#10;import com.example.permitely.data.storage.TokenStorage&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Repository handling authentication operations with real backend integration&#10; */&#10;@Singleton&#10;class AuthRepository @Inject constructor(&#10;    private val authApiService: AuthApiService,&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;&#10;    /**&#10;     * Authenticate user with backend API&#10;     */&#10;    suspend fun login(loginRequest: LoginRequest): Flow&lt;AuthResult&gt; = flow {&#10;        try {&#10;            emit(AuthResult.Loading)&#10;&#10;            // Log the request data for debugging&#10;            println(&quot;Login Request: email=${loginRequest.email}, password=[HIDDEN]&quot;)&#10;&#10;            val response = authApiService.login(loginRequest)&#10;&#10;            // Log the response for debugging&#10;            println(&quot;Login Response Code: ${response.code()}&quot;)&#10;            println(&quot;Login Response Success: ${response.isSuccessful}&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val apiResponse = response.body()&#10;                println(&quot;Login API Response: success=${apiResponse?.success}, data=${apiResponse?.data}&quot;)&#10;&#10;                if (apiResponse?.success == true &amp;&amp; apiResponse.data != null) {&#10;                    // Handle successful login response&#10;                    val userData = apiResponse.data.user&#10;                    val tokens = apiResponse.data.tokens&#10;&#10;                    println(&quot;Login User Data: id=${userData.id}, name=${userData.name}, role=${userData.role}&quot;)&#10;                    println(&quot;Login Tokens: accessToken length=${tokens.accessToken.length}, refreshToken length=${tokens.refreshToken.length}&quot;)&#10;&#10;                    // Save tokens securely&#10;                    tokenStorage.saveTokens(&#10;                        accessToken = tokens.accessToken,&#10;                        refreshToken = tokens.refreshToken&#10;                    )&#10;&#10;                    // Save user information&#10;                    tokenStorage.saveUserInfo(&#10;                        id = userData.id.toString(),&#10;                        name = userData.name,&#10;                        email = userData.email,&#10;                        role = userData.role&#10;                    )&#10;&#10;                    emit(AuthResult.Success(&quot;Login successful&quot;))&#10;                } else if (apiResponse != null &amp;&amp; apiResponse.data != null) {&#10;                    // Fallback: Try to process the response even if success check fails&#10;                    println(&quot;Login Fallback: Attempting to process response without success check&quot;)&#10;                    try {&#10;                        val userData = apiResponse.data.user&#10;                        val tokens = apiResponse.data.tokens&#10;&#10;                        println(&quot;Login Fallback User Data: id=${userData.id}, name=${userData.name}, role=${userData.role}&quot;)&#10;&#10;                        // Save tokens securely&#10;                        tokenStorage.saveTokens(&#10;                            accessToken = tokens.accessToken,&#10;                            refreshToken = tokens.refreshToken&#10;                        )&#10;&#10;                        // Save user information&#10;                        tokenStorage.saveUserInfo(&#10;                            id = userData.id.toString(),&#10;                            name = userData.name,&#10;                            email = userData.email,&#10;                            role = userData.role&#10;                        )&#10;&#10;                        emit(AuthResult.Success(&quot;Login successful&quot;))&#10;                    } catch (e: Exception) {&#10;                        println(&quot;Login Fallback Failed: ${e.message}&quot;)&#10;                        emit(AuthResult.Error(&quot;Login response format error: ${e.message}&quot;))&#10;                    }&#10;                } else {&#10;                    println(&quot;Login Failed: success=${apiResponse?.success}, hasData=${apiResponse?.data != null}&quot;)&#10;                    println(&quot;Login Message: ${apiResponse?.message}&quot;)&#10;                    emit(AuthResult.Error(apiResponse?.message ?: &quot;Login failed - response parsing issue&quot;))&#10;                }&#10;            } else {&#10;                // Get the actual error response body for debugging&#10;                val errorBody = response.errorBody()?.string()&#10;                println(&quot;Login HTTP Error ${response.code()}: $errorBody&quot;)&#10;&#10;                val errorMessage = when (response.code()) {&#10;                    400 -&gt; &quot;Invalid email or password format&quot;&#10;                    401 -&gt; &quot;Invalid credentials&quot;&#10;                    500 -&gt; &quot;Server error. Please try again later&quot;&#10;                    else -&gt; &quot;Login failed. Please try again&quot;&#10;                }&#10;                emit(AuthResult.Error(errorMessage))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Handle network errors with detailed logging&#10;            println(&quot;Login Exception: ${e.javaClass.simpleName}: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;&#10;            val errorMessage = when (e) {&#10;                is java.net.UnknownHostException -&gt; &quot;No internet connection&quot;&#10;                is java.net.SocketTimeoutException -&gt; &quot;Connection timeout&quot;&#10;                is com.google.gson.JsonSyntaxException -&gt; &quot;Invalid response format from server&quot;&#10;                is com.google.gson.JsonParseException -&gt; &quot;Failed to parse server response&quot;&#10;                else -&gt; &quot;Network error: ${e.message ?: &quot;Unknown error&quot;}&quot;&#10;            }&#10;            emit(AuthResult.Error(errorMessage))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Register new user with backend API&#10;     */&#10;    suspend fun signup(signupRequest: SignupRequest): Flow&lt;AuthResult&gt; = flow {&#10;        try {&#10;            emit(AuthResult.Loading)&#10;&#10;            // Log the request data for debugging&#10;            println(&quot;Signup Request: name=${signupRequest.name}, email=${signupRequest.email}, phone=${signupRequest.phoneNumber}, role=${signupRequest.role}&quot;)&#10;&#10;            val response = authApiService.signup(signupRequest)&#10;&#10;            if (response.isSuccessful) {&#10;                val apiResponse = response.body()&#10;                if (apiResponse?.isSuccess == true &amp;&amp; apiResponse.data != null) {&#10;                    val userData = apiResponse.data.user&#10;                    val tokens = apiResponse.data.tokens&#10;&#10;                    // Save tokens securely&#10;                    tokenStorage.saveTokens(&#10;                        accessToken = tokens.accessToken,&#10;                        refreshToken = tokens.refreshToken&#10;                    )&#10;&#10;                    // Save user information&#10;                    tokenStorage.saveUserInfo(&#10;                        id = userData.id.toString(), // Convert Int to String for storage&#10;                        name = userData.name,&#10;                        email = userData.email,&#10;                        role = userData.role&#10;                    )&#10;&#10;                    emit(AuthResult.Success(&quot;Account created successfully&quot;))&#10;                } else {&#10;                    emit(AuthResult.Error(apiResponse?.message ?: &quot;Signup failed&quot;))&#10;                }&#10;            } else {&#10;                // Get the actual error response body for debugging&#10;                val errorBody = response.errorBody()?.string()&#10;                println(&quot;Signup HTTP Error ${response.code()}: $errorBody&quot;)&#10;&#10;                // Handle HTTP error codes&#10;                val errorMessage = when (response.code()) {&#10;                    400 -&gt; {&#10;                        // Try to parse the actual error message from backend&#10;                        if (errorBody?.contains(&quot;email&quot;) == true) &quot;Invalid email format&quot;&#10;                        else if (errorBody?.contains(&quot;password&quot;) == true) &quot;Password must be at least 8 characters with uppercase, lowercase, number, and special character&quot;&#10;                        else if (errorBody?.contains(&quot;phone&quot;) == true) &quot;Invalid phone number format&quot;&#10;                        else if (errorBody?.contains(&quot;role&quot;) == true) &quot;Invalid role. Must be admin, host, or guard&quot;&#10;                        else &quot;Invalid input data. Please check your information&quot;&#10;                    }&#10;                    409 -&gt; &quot;User already exists with this email&quot;&#10;                    500 -&gt; &quot;Server error. Please try again later&quot;&#10;                    else -&gt; &quot;Signup failed. Please try again&quot;&#10;                }&#10;                emit(AuthResult.Error(errorMessage))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Handle network errors&#10;            val errorMessage = when (e) {&#10;                is java.net.UnknownHostException -&gt; &quot;No internet connection&quot;&#10;                is java.net.SocketTimeoutException -&gt; &quot;Connection timeout&quot;&#10;                else -&gt; e.message ?: &quot;Network error occurred&quot;&#10;            }&#10;            emit(AuthResult.Error(errorMessage))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Logout user and clear stored tokens&#10;     */&#10;    suspend fun logout(): Flow&lt;AuthResult&gt; = flow {&#10;        try {&#10;            println(&quot;DEBUG: Starting logout process&quot;)&#10;            emit(AuthResult.Loading)&#10;&#10;            // Get refresh token for logout request&#10;            val refreshToken = tokenStorage.getRefreshToken().first()&#10;            println(&quot;DEBUG: Retrieved refresh token: ${refreshToken?.take(10)}...&quot;)&#10;&#10;            if (refreshToken != null) {&#10;                try {&#10;                    val response = authApiService.logout(LogoutRequest(refreshToken))&#10;                    println(&quot;DEBUG: Logout API response: ${response.code()}&quot;)&#10;                } catch (e: Exception) {&#10;                    println(&quot;DEBUG: Logout API failed: ${e.message}&quot;)&#10;                    // Continue with local cleanup even if API fails&#10;                }&#10;            }&#10;&#10;            // Always clear local tokens regardless of API response&#10;            // This ensures the user is logged out locally&#10;            println(&quot;DEBUG: Clearing all tokens from storage&quot;)&#10;            tokenStorage.clearAll()&#10;            println(&quot;DEBUG: Logout completed successfully&quot;)&#10;            emit(AuthResult.Success(&quot;Logged out successfully&quot;))&#10;&#10;        } catch (e: Exception) {&#10;            println(&quot;DEBUG: Logout exception: ${e.message}&quot;)&#10;            // Even if logout API fails, clear local tokens&#10;            tokenStorage.clearAll()&#10;            emit(AuthResult.Success(&quot;Logged out successfully&quot;))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if user is currently logged in&#10;     */&#10;    fun isLoggedIn(): Flow&lt;Boolean&gt; = tokenStorage.isLoggedIn()&#10;&#10;    /**&#10;     * Get stored user information&#10;     */&#10;    fun getUserInfo(): Flow&lt;TokenStorage.UserInfo?&gt; = tokenStorage.getUserInfo()&#10;}&#10;&#10;/**&#10; * Sealed class representing authentication operation results&#10; */&#10;sealed class AuthResult {&#10;    object Loading : AuthResult()&#10;    data class Success(val message: String) : AuthResult()&#10;    data class Error(val message: String) : AuthResult()&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.data.repository&#10;&#10;import com.example.permitely.data.models.*&#10;import com.example.permitely.data.network.AuthApiService&#10;import com.example.permitely.data.storage.TokenStorage&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Repository handling authentication operations with real backend integration&#10; */&#10;@Singleton&#10;class AuthRepository @Inject constructor(&#10;    private val authApiService: AuthApiService,&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;&#10;    /**&#10;     * Authenticate user with backend API&#10;     */&#10;    suspend fun login(loginRequest: LoginRequest): Flow&lt;AuthResult&gt; = flow {&#10;        try {&#10;            emit(AuthResult.Loading)&#10;&#10;            // Log the request data for debugging&#10;            println(&quot;Login Request: email=${loginRequest.email}, password=[HIDDEN]&quot;)&#10;&#10;            val response = authApiService.login(loginRequest)&#10;&#10;            // Log the response for debugging&#10;            println(&quot;Login Response Code: ${response.code()}&quot;)&#10;            println(&quot;Login Response Success: ${response.isSuccessful}&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val apiResponse = response.body()&#10;                println(&quot;Login API Response: success=${apiResponse?.success}, data=${apiResponse?.data}&quot;)&#10;&#10;                if (apiResponse?.success == true &amp;&amp; apiResponse.data != null) {&#10;                    // Handle successful login response&#10;                    val userData = apiResponse.data.user&#10;                    val tokens = apiResponse.data.tokens&#10;&#10;                    println(&quot;Login User Data: id=${userData.id}, name=${userData.name}, role=${userData.role}&quot;)&#10;                    println(&quot;Login Tokens: accessToken length=${tokens.accessToken.length}, refreshToken length=${tokens.refreshToken.length}&quot;)&#10;&#10;                    // Save tokens securely&#10;                    tokenStorage.saveTokens(&#10;                        accessToken = tokens.accessToken,&#10;                        refreshToken = tokens.refreshToken&#10;                    )&#10;&#10;                    // Save user information&#10;                    tokenStorage.saveUserInfo(&#10;                        id = userData.id.toString(),&#10;                        name = userData.name,&#10;                        email = userData.email,&#10;                        role = userData.role&#10;                    )&#10;&#10;                    emit(AuthResult.Success(&quot;Login successful&quot;))&#10;                } else if (apiResponse != null &amp;&amp; apiResponse.data != null) {&#10;                    // Fallback: Try to process the response even if success check fails&#10;                    println(&quot;Login Fallback: Attempting to process response without success check&quot;)&#10;                    try {&#10;                        val userData = apiResponse.data.user&#10;                        val tokens = apiResponse.data.tokens&#10;&#10;                        println(&quot;Login Fallback User Data: id=${userData.id}, name=${userData.name}, role=${userData.role}&quot;)&#10;&#10;                        // Save tokens securely&#10;                        tokenStorage.saveTokens(&#10;                            accessToken = tokens.accessToken,&#10;                            refreshToken = tokens.refreshToken&#10;                        )&#10;&#10;                        // Save user information&#10;                        tokenStorage.saveUserInfo(&#10;                            id = userData.id.toString(),&#10;                            name = userData.name,&#10;                            email = userData.email,&#10;                            role = userData.role&#10;                        )&#10;&#10;                        emit(AuthResult.Success(&quot;Login successful&quot;))&#10;                    } catch (e: Exception) {&#10;                        println(&quot;Login Fallback Failed: ${e.message}&quot;)&#10;                        emit(AuthResult.Error(&quot;Login response format error: ${e.message}&quot;))&#10;                    }&#10;                } else {&#10;                    println(&quot;Login Failed: success=${apiResponse?.success}, hasData=${apiResponse?.data != null}&quot;)&#10;                    println(&quot;Login Message: ${apiResponse?.message}&quot;)&#10;                    emit(AuthResult.Error(apiResponse?.message ?: &quot;Login failed - response parsing issue&quot;))&#10;                }&#10;            } else {&#10;                // Get the actual error response body for debugging&#10;                val errorBody = response.errorBody()?.string()&#10;                println(&quot;Login HTTP Error ${response.code()}: $errorBody&quot;)&#10;&#10;                val errorMessage = when (response.code()) {&#10;                    400 -&gt; &quot;Invalid email or password format&quot;&#10;                    401 -&gt; &quot;Invalid credentials&quot;&#10;                    500 -&gt; &quot;Server error. Please try again later&quot;&#10;                    else -&gt; &quot;Login failed. Please try again&quot;&#10;                }&#10;                emit(AuthResult.Error(errorMessage))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Handle network errors with detailed logging&#10;            println(&quot;Login Exception: ${e.javaClass.simpleName}: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;&#10;            val errorMessage = when (e) {&#10;                is java.net.UnknownHostException -&gt; &quot;No internet connection&quot;&#10;                is java.net.SocketTimeoutException -&gt; &quot;Connection timeout&quot;&#10;                is com.google.gson.JsonSyntaxException -&gt; &quot;Invalid response format from server&quot;&#10;                is com.google.gson.JsonParseException -&gt; &quot;Failed to parse server response&quot;&#10;                else -&gt; &quot;Network error: ${e.message ?: &quot;Unknown error&quot;}&quot;&#10;            }&#10;            emit(AuthResult.Error(errorMessage))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Register new user with backend API&#10;     */&#10;    suspend fun signup(signupRequest: SignupRequest): Flow&lt;AuthResult&gt; = flow {&#10;        try {&#10;            emit(AuthResult.Loading)&#10;&#10;            // Log the request data for debugging&#10;            println(&quot;Signup Request: name=${signupRequest.name}, email=${signupRequest.email}, phone=${signupRequest.phoneNumber}, role=${signupRequest.role}&quot;)&#10;&#10;            val response = authApiService.signup(signupRequest)&#10;&#10;            if (response.isSuccessful) {&#10;                val apiResponse = response.body()&#10;                if (apiResponse?.success == true &amp;&amp; apiResponse.data != null) {&#10;                    val userData = apiResponse.data.user&#10;                    val tokens = apiResponse.data.tokens&#10;&#10;                    // Save tokens securely&#10;                    tokenStorage.saveTokens(&#10;                        accessToken = tokens.accessToken,&#10;                        refreshToken = tokens.refreshToken&#10;                    )&#10;&#10;                    // Save user information&#10;                    tokenStorage.saveUserInfo(&#10;                        id = userData.id.toString(), // Convert Int to String for storage&#10;                        name = userData.name,&#10;                        email = userData.email,&#10;                        role = userData.role&#10;                    )&#10;&#10;                    emit(AuthResult.Success(&quot;Account created successfully&quot;))&#10;                } else {&#10;                    emit(AuthResult.Error(apiResponse?.message ?: &quot;Signup failed&quot;))&#10;                }&#10;            } else {&#10;                // Get the actual error response body for debugging&#10;                val errorBody = response.errorBody()?.string()&#10;                println(&quot;Signup HTTP Error ${response.code()}: $errorBody&quot;)&#10;&#10;                // Handle HTTP error codes&#10;                val errorMessage = when (response.code()) {&#10;                    400 -&gt; {&#10;                        // Try to parse the actual error message from backend&#10;                        if (errorBody?.contains(&quot;email&quot;) == true) &quot;Invalid email format&quot;&#10;                        else if (errorBody?.contains(&quot;password&quot;) == true) &quot;Password must be at least 8 characters with uppercase, lowercase, number, and special character&quot;&#10;                        else if (errorBody?.contains(&quot;phone&quot;) == true) &quot;Invalid phone number format&quot;&#10;                        else if (errorBody?.contains(&quot;role&quot;) == true) &quot;Invalid role. Must be admin, host, or guard&quot;&#10;                        else &quot;Invalid input data. Please check your information&quot;&#10;                    }&#10;                    409 -&gt; &quot;User already exists with this email&quot;&#10;                    500 -&gt; &quot;Server error. Please try again later&quot;&#10;                    else -&gt; &quot;Signup failed. Please try again&quot;&#10;                }&#10;                emit(AuthResult.Error(errorMessage))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Handle network errors&#10;            val errorMessage = when (e) {&#10;                is java.net.UnknownHostException -&gt; &quot;No internet connection&quot;&#10;                is java.net.SocketTimeoutException -&gt; &quot;Connection timeout&quot;&#10;                else -&gt; e.message ?: &quot;Network error occurred&quot;&#10;            }&#10;            emit(AuthResult.Error(errorMessage))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Logout user and clear stored tokens&#10;     */&#10;    suspend fun logout(): Flow&lt;AuthResult&gt; = flow {&#10;        try {&#10;            println(&quot;DEBUG: Starting logout process&quot;)&#10;            emit(AuthResult.Loading)&#10;&#10;            // Get refresh token for logout request&#10;            val refreshToken = tokenStorage.getRefreshToken().first()&#10;            println(&quot;DEBUG: Retrieved refresh token: ${refreshToken?.take(10)}...&quot;)&#10;&#10;            if (refreshToken != null) {&#10;                try {&#10;                    val response = authApiService.logout(LogoutRequest(refreshToken))&#10;                    println(&quot;DEBUG: Logout API response: ${response.code()}&quot;)&#10;                } catch (e: Exception) {&#10;                    println(&quot;DEBUG: Logout API failed: ${e.message}&quot;)&#10;                    // Continue with local cleanup even if API fails&#10;                }&#10;            }&#10;&#10;            // Always clear local tokens regardless of API response&#10;            // This ensures the user is logged out locally&#10;            println(&quot;DEBUG: Clearing all tokens from storage&quot;)&#10;            tokenStorage.clearAll()&#10;            println(&quot;DEBUG: Logout completed successfully&quot;)&#10;            emit(AuthResult.Success(&quot;Logged out successfully&quot;))&#10;&#10;        } catch (e: Exception) {&#10;            println(&quot;DEBUG: Logout exception: ${e.message}&quot;)&#10;            // Even if logout API fails, clear local tokens&#10;            tokenStorage.clearAll()&#10;            emit(AuthResult.Success(&quot;Logged out successfully&quot;))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if user is currently logged in&#10;     */&#10;    fun isLoggedIn(): Flow&lt;Boolean&gt; = tokenStorage.isLoggedIn()&#10;&#10;    /**&#10;     * Get stored user information&#10;     */&#10;    fun getUserInfo(): Flow&lt;TokenStorage.UserInfo?&gt; = tokenStorage.getUserInfo()&#10;}&#10;&#10;/**&#10; * Sealed class representing authentication operation results&#10; */&#10;sealed class AuthResult {&#10;    object Loading : AuthResult()&#10;    data class Success(val message: String) : AuthResult()&#10;    data class Error(val message: String) : AuthResult()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/repository/DashboardRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/repository/DashboardRepository.kt" />
              <option name="originalContent" value="package com.example.permitely.data.repository&#10;&#10;import com.example.permitely.data.models.DashboardStats&#10;import com.example.permitely.data.network.DashboardApiService&#10;import com.example.permitely.data.network.ProfileApiService&#10;import com.example.permitely.data.storage.TokenStorage&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Repository for dashboard-related operations&#10; * Handles data operations and provides a clean API for ViewModels&#10; */&#10;@Singleton&#10;class DashboardRepository @Inject constructor(&#10;    private val dashboardApiService: DashboardApiService,&#10;    private val profileApiService: ProfileApiService,&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;&#10;    /**&#10;     * Fetch dashboard statistics from the API&#10;     * @return Flow&lt;Result&lt;DashboardStats&gt;&gt; - Flow containing success/failure results&#10;     */&#10;    fun getDashboardStats(): Flow&lt;Result&lt;DashboardStats&gt;&gt; = flow {&#10;        try {&#10;            val token = tokenStorage.getAccessToken().first()&#10;            if (token == null || token.isEmpty()) {&#10;                emit(Result.failure(Exception(&quot;No access token available&quot;)))&#10;                return@flow&#10;            }&#10;&#10;            val response = dashboardApiService.getDashboardStats(&quot;Bearer $token&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val body = response.body()&#10;                if (body?.success == true &amp;&amp; body.data != null) {&#10;                    emit(Result.success(body.data))&#10;                } else {&#10;                    emit(Result.failure(Exception(body?.message ?: &quot;Failed to fetch dashboard stats&quot;)))&#10;                }&#10;            } else {&#10;                emit(Result.failure(Exception(&quot;HTTP ${response.code()}: ${response.message()}&quot;)))&#10;            }&#10;        } catch (e: Exception) {&#10;            emit(Result.failure(e))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get fresh user profile data for dashboard&#10;     * @return Flow&lt;Result&lt;String&gt;&gt; - Returns the user's current name&#10;     */&#10;    fun getUserName(): Flow&lt;Result&lt;String&gt;&gt; = flow {&#10;        try {&#10;            val token = tokenStorage.getAccessToken().first()&#10;            if (token == null || token.isEmpty()) {&#10;                emit(Result.failure(Exception(&quot;No access token available&quot;)))&#10;                return@flow&#10;            }&#10;&#10;            // Try to get fresh data from profile API&#10;            val response = profileApiService.getUserProfile(&quot;Bearer $token&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val body = response.body()&#10;                if (body?.success == true &amp;&amp; body.data != null) {&#10;                    val profileData = body.data&#10;&#10;                    // Update TokenStorage with fresh data to keep everything in sync&#10;                    tokenStorage.saveUserInfo(&#10;                        id = profileData.userId.toString(),&#10;                        name = profileData.name,&#10;                        email = profileData.email,&#10;                        role = profileData.role&#10;                    )&#10;&#10;                    emit(Result.success(profileData.name))&#10;                    return@flow&#10;                }&#10;            }&#10;&#10;            // Fallback to TokenStorage&#10;            val userInfo = tokenStorage.getUserInfo().first()&#10;            if (userInfo != null) {&#10;                emit(Result.success(userInfo.name))&#10;            } else {&#10;                emit(Result.failure(Exception(&quot;No user data available&quot;)))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback to local storage on network error&#10;            try {&#10;                val userInfo = tokenStorage.getUserInfo().first()&#10;                if (userInfo != null) {&#10;                    emit(Result.success(userInfo.name))&#10;                } else {&#10;                    emit(Result.failure(e))&#10;                }&#10;            } catch (fallbackError: Exception) {&#10;                emit(Result.failure(e))&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.data.repository&#10;&#10;import com.example.permitely.data.models.DashboardStats&#10;import com.example.permitely.data.models.RecentVisitor&#10;import com.example.permitely.data.network.DashboardApiService&#10;import com.example.permitely.data.network.ProfileApiService&#10;import com.example.permitely.data.storage.TokenStorage&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Repository for dashboard-related operations&#10; * Handles data operations and provides a clean API for ViewModels&#10; */&#10;@Singleton&#10;class DashboardRepository @Inject constructor(&#10;    private val dashboardApiService: DashboardApiService,&#10;    private val profileApiService: ProfileApiService,&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;&#10;    /**&#10;     * Fetch dashboard statistics from the API&#10;     * @return Flow&lt;Result&lt;DashboardStats&gt;&gt; - Flow containing success/failure results&#10;     */&#10;    fun getDashboardStats(): Flow&lt;Result&lt;DashboardStats&gt;&gt; = flow {&#10;        try {&#10;            val token = tokenStorage.getAccessToken().first()&#10;            if (token == null || token.isEmpty()) {&#10;                emit(Result.failure(Exception(&quot;No access token available&quot;)))&#10;                return@flow&#10;            }&#10;&#10;            val response = dashboardApiService.getDashboardStats(&quot;Bearer $token&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val body = response.body()&#10;                if (body?.success == true &amp;&amp; body.data != null) {&#10;                    emit(Result.success(body.data))&#10;                } else {&#10;                    emit(Result.failure(Exception(body?.message ?: &quot;Failed to fetch dashboard stats&quot;)))&#10;                }&#10;            } else {&#10;                emit(Result.failure(Exception(&quot;HTTP ${response.code()}: ${response.message()}&quot;)))&#10;            }&#10;        } catch (e: Exception) {&#10;            emit(Result.failure(e))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get fresh user profile data for dashboard&#10;     * @return Flow&lt;Result&lt;String&gt;&gt; - Returns the user's current name&#10;     */&#10;    fun getUserName(): Flow&lt;Result&lt;String&gt;&gt; = flow {&#10;        try {&#10;            val token = tokenStorage.getAccessToken().first()&#10;            if (token == null || token.isEmpty()) {&#10;                emit(Result.failure(Exception(&quot;No access token available&quot;)))&#10;                return@flow&#10;            }&#10;&#10;            // Try to get fresh data from profile API&#10;            val response = profileApiService.getUserProfile(&quot;Bearer $token&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val body = response.body()&#10;                if (body?.success == true &amp;&amp; body.data != null) {&#10;                    val profileData = body.data&#10;&#10;                    // Update TokenStorage with fresh data to keep everything in sync&#10;                    tokenStorage.saveUserInfo(&#10;                        id = profileData.userId.toString(),&#10;                        name = profileData.name,&#10;                        email = profileData.email,&#10;                        role = profileData.role&#10;                    )&#10;&#10;                    emit(Result.success(profileData.name))&#10;                    return@flow&#10;                }&#10;            }&#10;&#10;            // Fallback to TokenStorage&#10;            val userInfo = tokenStorage.getUserInfo().first()&#10;            if (userInfo != null) {&#10;                emit(Result.success(userInfo.name))&#10;            } else {&#10;                emit(Result.failure(Exception(&quot;No user data available&quot;)))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback to local storage on network error&#10;            try {&#10;                val userInfo = tokenStorage.getUserInfo().first()&#10;                if (userInfo != null) {&#10;                    emit(Result.success(userInfo.name))&#10;                } else {&#10;                    emit(Result.failure(e))&#10;                }&#10;            } catch (fallbackError: Exception) {&#10;                emit(Result.failure(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch recent visitors from the API&#10;     * @return Flow&lt;Result&lt;List&lt;RecentVisitor&gt;&gt;&gt; - Flow containing success/failure results&#10;     */&#10;    fun getRecentVisitors(): Flow&lt;Result&lt;List&lt;RecentVisitor&gt;&gt;&gt; = flow {&#10;        try {&#10;            val token = tokenStorage.getAccessToken().first()&#10;            if (token == null || token.isEmpty()) {&#10;                emit(Result.failure(Exception(&quot;No access token available&quot;)))&#10;                return@flow&#10;            }&#10;&#10;            val response = dashboardApiService.getRecentVisitors(&quot;Bearer $token&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val body = response.body()&#10;                if (body?.success == true &amp;&amp; body.data != null) {&#10;                    emit(Result.success(body.data))&#10;                } else {&#10;                    emit(Result.failure(Exception(body?.message ?: &quot;Failed to fetch recent visitors&quot;)))&#10;                }&#10;            } else {&#10;                emit(Result.failure(Exception(&quot;HTTP ${response.code()}: ${response.message()}&quot;)))&#10;            }&#10;        } catch (e: Exception) {&#10;            emit(Result.failure(e))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/repository/GuardRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/data/repository/GuardRepository.kt" />
              <option name="originalContent" value="package com.example.permitely.data.repository&#10;&#10;import com.example.permitely.data.models.*&#10;import com.example.permitely.data.network.GuardApiService&#10;import com.example.permitely.data.storage.TokenStorage&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Repository handling guard operations with backend integration&#10; */&#10;@Singleton&#10;class GuardRepository @Inject constructor(&#10;    private val guardApiService: GuardApiService,&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;&#10;    /**&#10;     * Scan visitor pass using the pass ID extracted from QR code&#10;     * @param passId The pass ID extracted from QR code URL&#10;     * @return Flow&lt;Result&lt;PassScanResult&gt;&gt; indicating success or failure&#10;     */&#10;    suspend fun scanPass(passId: Int): Flow&lt;Result&lt;PassScanResult&gt;&gt; = flow {&#10;        try {&#10;            println(&quot;GuardRepository: Scanning pass with ID: $passId&quot;)&#10;&#10;            // Get the access token&#10;            val accessToken = tokenStorage.getAccessToken().first()&#10;            if (accessToken.isNullOrEmpty()) {&#10;                emit(Result.success(PassScanResult(&#10;                    isSuccess = false,&#10;                    errorMessage = &quot;Authentication required. Please login again.&quot;&#10;                )))&#10;                return@flow&#10;            }&#10;&#10;            val response = guardApiService.scanPass(passId, &quot;Bearer $accessToken&quot;)&#10;&#10;            println(&quot;GuardRepository: Scan response code: ${response.code()}&quot;)&#10;            println(&quot;GuardRepository: Scan response success: ${response.isSuccessful}&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val apiResponse = response.body()&#10;                println(&quot;GuardRepository: API Response: isSuccess=${apiResponse?.isSuccess}, data=${apiResponse?.data}&quot;)&#10;&#10;                if (apiResponse?.isSuccess == true &amp;&amp; apiResponse.data != null) {&#10;                    val scanData = apiResponse.data&#10;&#10;                    println(&quot;GuardRepository: Pass scan successful for visitor: ${scanData.visitor.name}&quot;)&#10;&#10;                    val scanResult = PassScanResult(&#10;                        isSuccess = true,&#10;                        pass = scanData.pass,&#10;                        visitor = scanData.visitor&#10;                    )&#10;&#10;                    emit(Result.success(scanResult))&#10;                } else {&#10;                    val errorMessage = apiResponse?.message ?: &quot;Unknown error occurred&quot;&#10;                    println(&quot;GuardRepository: API returned error: $errorMessage&quot;)&#10;&#10;                    val scanResult = PassScanResult(&#10;                        isSuccess = false,&#10;                        errorMessage = errorMessage&#10;                    )&#10;&#10;                    emit(Result.success(scanResult))&#10;                }&#10;            } else {&#10;                // Handle HTTP error responses&#10;                val errorBody = response.errorBody()?.string()&#10;                println(&quot;GuardRepository: HTTP Error ${response.code()}: $errorBody&quot;)&#10;&#10;                val errorMessage = when (response.code()) {&#10;                    400 -&gt; &quot;Invalid pass ID format&quot;&#10;                    404 -&gt; &quot;Pass not found&quot;&#10;                    409 -&gt; {&#10;                        // Try to parse specific error messages from response body&#10;                        when {&#10;                            errorBody?.contains(&quot;already processed&quot;) == true -&gt; &quot;Pass already processed&quot;&#10;                            errorBody?.contains(&quot;already approved&quot;) == true -&gt; &quot;Visitor is already approved&quot;&#10;                            errorBody?.contains(&quot;expired&quot;) == true -&gt; &quot;Pass has expired&quot;&#10;                            else -&gt; &quot;Pass cannot be processed&quot;&#10;                        }&#10;                    }&#10;                    500 -&gt; &quot;Server error. Please try again later&quot;&#10;                    else -&gt; &quot;Failed to scan pass. Please try again&quot;&#10;                }&#10;&#10;                val scanResult = PassScanResult(&#10;                    isSuccess = false,&#10;                    errorMessage = errorMessage&#10;                )&#10;&#10;                emit(Result.success(scanResult))&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;GuardRepository: Exception during pass scan: ${e.javaClass.simpleName}: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;&#10;            val errorMessage = when (e) {&#10;                is java.net.UnknownHostException -&gt; &quot;No internet connection&quot;&#10;                is java.net.SocketTimeoutException -&gt; &quot;Connection timeout&quot;&#10;                is com.google.gson.JsonSyntaxException -&gt; &quot;Invalid response format from server&quot;&#10;                is com.google.gson.JsonParseException -&gt; &quot;Failed to parse server response&quot;&#10;                else -&gt; &quot;Network error: ${e.message ?: &quot;Unknown error&quot;}&quot;&#10;            }&#10;&#10;            val scanResult = PassScanResult(&#10;                isSuccess = false,&#10;                errorMessage = errorMessage&#10;            )&#10;&#10;            emit(Result.success(scanResult))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract pass ID from QR code URL&#10;     * Expected format: https://yourbackend.com/api/guard/scan/789&#10;     * @param qrCodeUrl The complete QR code URL&#10;     * @return pass ID if valid URL, null otherwise&#10;     */&#10;    fun extractPassIdFromQrCode(qrCodeUrl: String): Int? {&#10;        return try {&#10;            // Extract pass ID from URL pattern: .../api/guard/scan/{passId}&#10;            val regex = Regex(&quot;.*/api/guard/scan/(\\d+)/?.*&quot;)&#10;            val matchResult = regex.find(qrCodeUrl)&#10;            matchResult?.groupValues?.get(1)?.toIntOrNull()&#10;        } catch (e: Exception) {&#10;            println(&quot;GuardRepository: Failed to extract pass ID from QR code: $qrCodeUrl&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get today's guard statistics from API&#10;     * @return Flow&lt;Result&lt;GuardTodayStatsData&gt;&gt; with today's visitor statistics&#10;     */&#10;    suspend fun getTodayStats(): Flow&lt;Result&lt;GuardTodayStatsData&gt;&gt; = flow {&#10;        try {&#10;            println(&quot;GuardRepository: Fetching today's guard statistics&quot;)&#10;&#10;            // Get the access token&#10;            val accessToken = tokenStorage.getAccessToken().first()&#10;            if (accessToken.isNullOrEmpty()) {&#10;                emit(Result.failure(Exception(&quot;Authentication required. Please login again.&quot;)))&#10;                return@flow&#10;            }&#10;&#10;            val response = guardApiService.getTodayStats(&quot;Bearer $accessToken&quot;)&#10;&#10;            println(&quot;GuardRepository: Stats response code: ${response.code()}&quot;)&#10;            println(&quot;GuardRepository: Stats response success: ${response.isSuccessful}&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val apiResponse = response.body()&#10;                println(&quot;GuardRepository: API Response: isSuccess=${apiResponse?.isSuccess}, data=${apiResponse?.data}&quot;)&#10;&#10;                if (apiResponse?.isSuccess == true &amp;&amp; apiResponse.data != null) {&#10;                    val statsResponse = apiResponse.data&#10;                    val statsData = statsResponse.stats  // Extract from nested structure&#10;&#10;                    println(&quot;GuardRepository: Today's stats loaded successfully - Total: ${statsData.totalVisitors}&quot;)&#10;&#10;                    emit(Result.success(statsData))&#10;                } else {&#10;                    val errorMessage = apiResponse?.message ?: &quot;Failed to load today's statistics&quot;&#10;                    println(&quot;GuardRepository: API returned error: $errorMessage&quot;)&#10;                    emit(Result.failure(Exception(errorMessage)))&#10;                }&#10;            } else {&#10;                // Handle HTTP error responses&#10;                val errorBody = response.errorBody()?.string()&#10;                println(&quot;GuardRepository: HTTP Error ${response.code()}: $errorBody&quot;)&#10;&#10;                val errorMessage = when (response.code()) {&#10;                    401 -&gt; &quot;Unauthorized access. Please login again&quot;&#10;                    403 -&gt; &quot;Access denied. Guard permissions required&quot;&#10;                    404 -&gt; &quot;Statistics endpoint not found&quot;&#10;                    500 -&gt; &quot;Server error. Please try again later&quot;&#10;                    else -&gt; &quot;Failed to load statistics. Please try again&quot;&#10;                }&#10;&#10;                emit(Result.failure(Exception(errorMessage)))&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;GuardRepository: Exception during stats fetch: ${e.javaClass.simpleName}: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;&#10;            val errorMessage = when (e) {&#10;                is java.net.UnknownHostException -&gt; &quot;No internet connection&quot;&#10;                is java.net.SocketTimeoutException -&gt; &quot;Connection timeout&quot;&#10;                is com.google.gson.JsonSyntaxException -&gt; &quot;Invalid response format from server&quot;&#10;                is com.google.gson.JsonParseException -&gt; &quot;Failed to parse server response&quot;&#10;                else -&gt; &quot;Network error: ${e.message ?: &quot;Unknown error&quot;}&quot;&#10;            }&#10;&#10;            emit(Result.failure(Exception(errorMessage)))&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.data.repository&#10;&#10;import com.example.permitely.data.models.*&#10;import com.example.permitely.data.network.GuardApiService&#10;import com.example.permitely.data.storage.TokenStorage&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Repository handling guard operations with backend integration&#10; */&#10;@Singleton&#10;class GuardRepository @Inject constructor(&#10;    private val guardApiService: GuardApiService,&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;&#10;    /**&#10;     * Scan visitor pass using the pass ID extracted from QR code&#10;     * @param passId The pass ID extracted from QR code URL&#10;     * @return Flow&lt;Result&lt;PassScanResult&gt;&gt; indicating success or failure&#10;     */&#10;    suspend fun scanPass(passId: Int): Flow&lt;Result&lt;PassScanResult&gt;&gt; = flow {&#10;        try {&#10;            println(&quot;GuardRepository: Scanning pass with ID: $passId&quot;)&#10;&#10;            // Get the access token&#10;            val accessToken = tokenStorage.getAccessToken().first()&#10;            if (accessToken.isNullOrEmpty()) {&#10;                emit(Result.success(PassScanResult(&#10;                    isSuccess = false,&#10;                    errorMessage = &quot;Authentication required. Please login again.&quot;&#10;                )))&#10;                return@flow&#10;            }&#10;&#10;            val response = guardApiService.scanPass(passId, &quot;Bearer $accessToken&quot;)&#10;&#10;            println(&quot;GuardRepository: Scan response code: ${response.code()}&quot;)&#10;            println(&quot;GuardRepository: Scan response success: ${response.isSuccessful}&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val apiResponse = response.body()&#10;                println(&quot;GuardRepository: API Response: success=${apiResponse?.success}, data=${apiResponse?.data}&quot;)&#10;&#10;                if (apiResponse?.success == true &amp;&amp; apiResponse.data != null) {&#10;                    val scanData = apiResponse.data&#10;&#10;                    println(&quot;GuardRepository: Pass scan successful for visitor: ${scanData.visitor.name}&quot;)&#10;&#10;                    val scanResult = PassScanResult(&#10;                        isSuccess = true,&#10;                        pass = scanData.pass,&#10;                        visitor = scanData.visitor&#10;                    )&#10;&#10;                    emit(Result.success(scanResult))&#10;                } else {&#10;                    val errorMessage = apiResponse?.message ?: &quot;Unknown error occurred&quot;&#10;                    println(&quot;GuardRepository: API returned error: $errorMessage&quot;)&#10;&#10;                    val scanResult = PassScanResult(&#10;                        isSuccess = false,&#10;                        errorMessage = errorMessage&#10;                    )&#10;&#10;                    emit(Result.success(scanResult))&#10;                }&#10;            } else {&#10;                // Handle HTTP error responses&#10;                val errorBody = response.errorBody()?.string()&#10;                println(&quot;GuardRepository: HTTP Error ${response.code()}: $errorBody&quot;)&#10;&#10;                val errorMessage = when (response.code()) {&#10;                    400 -&gt; &quot;Invalid pass ID format&quot;&#10;                    404 -&gt; &quot;Pass not found&quot;&#10;                    409 -&gt; {&#10;                        // Try to parse specific error messages from response body&#10;                        when {&#10;                            errorBody?.contains(&quot;already processed&quot;) == true -&gt; &quot;Pass already processed&quot;&#10;                            errorBody?.contains(&quot;already approved&quot;) == true -&gt; &quot;Visitor is already approved&quot;&#10;                            errorBody?.contains(&quot;expired&quot;) == true -&gt; &quot;Pass has expired&quot;&#10;                            else -&gt; &quot;Pass cannot be processed&quot;&#10;                        }&#10;                    }&#10;                    500 -&gt; &quot;Server error. Please try again later&quot;&#10;                    else -&gt; &quot;Failed to scan pass. Please try again&quot;&#10;                }&#10;&#10;                val scanResult = PassScanResult(&#10;                    isSuccess = false,&#10;                    errorMessage = errorMessage&#10;                )&#10;&#10;                emit(Result.success(scanResult))&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;GuardRepository: Exception during pass scan: ${e.javaClass.simpleName}: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;&#10;            val errorMessage = when (e) {&#10;                is java.net.UnknownHostException -&gt; &quot;No internet connection&quot;&#10;                is java.net.SocketTimeoutException -&gt; &quot;Connection timeout&quot;&#10;                is com.google.gson.JsonSyntaxException -&gt; &quot;Invalid response format from server&quot;&#10;                is com.google.gson.JsonParseException -&gt; &quot;Failed to parse server response&quot;&#10;                else -&gt; &quot;Network error: ${e.message ?: &quot;Unknown error&quot;}&quot;&#10;            }&#10;&#10;            val scanResult = PassScanResult(&#10;                isSuccess = false,&#10;                errorMessage = errorMessage&#10;            )&#10;&#10;            emit(Result.success(scanResult))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract pass ID from QR code URL&#10;     * Expected format: https://yourbackend.com/api/guard/scan/789&#10;     * @param qrCodeUrl The complete QR code URL&#10;     * @return pass ID if valid URL, null otherwise&#10;     */&#10;    fun extractPassIdFromQrCode(qrCodeUrl: String): Int? {&#10;        return try {&#10;            // Extract pass ID from URL pattern: .../api/guard/scan/{passId}&#10;            val regex = Regex(&quot;.*/api/guard/scan/(\\d+)/?.*&quot;)&#10;            val matchResult = regex.find(qrCodeUrl)&#10;            matchResult?.groupValues?.get(1)?.toIntOrNull()&#10;        } catch (e: Exception) {&#10;            println(&quot;GuardRepository: Failed to extract pass ID from QR code: $qrCodeUrl&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get today's guard statistics from API&#10;     * @return Flow&lt;Result&lt;GuardTodayStatsData&gt;&gt; with today's visitor statistics&#10;     */&#10;    suspend fun getTodayStats(): Flow&lt;Result&lt;GuardTodayStatsData&gt;&gt; = flow {&#10;        try {&#10;            println(&quot;GuardRepository: Fetching today's guard statistics&quot;)&#10;&#10;            // Get the access token&#10;            val accessToken = tokenStorage.getAccessToken().first()&#10;            if (accessToken.isNullOrEmpty()) {&#10;                emit(Result.failure(Exception(&quot;Authentication required. Please login again.&quot;)))&#10;                return@flow&#10;            }&#10;&#10;            val response = guardApiService.getTodayStats(&quot;Bearer $accessToken&quot;)&#10;&#10;            println(&quot;GuardRepository: Stats response code: ${response.code()}&quot;)&#10;            println(&quot;GuardRepository: Stats response success: ${response.isSuccessful}&quot;)&#10;&#10;            if (response.isSuccessful) {&#10;                val apiResponse = response.body()&#10;                println(&quot;GuardRepository: API Response: success=${apiResponse?.success}, data=${apiResponse?.data}&quot;)&#10;&#10;                if (apiResponse?.success == true &amp;&amp; apiResponse.data != null) {&#10;                    val statsResponse = apiResponse.data&#10;                    val statsData = statsResponse.stats  // Extract from nested structure&#10;&#10;                    println(&quot;GuardRepository: Today's stats loaded successfully - Total: ${statsData.totalVisitors}&quot;)&#10;&#10;                    emit(Result.success(statsData))&#10;                } else {&#10;                    val errorMessage = apiResponse?.message ?: &quot;Failed to load today's statistics&quot;&#10;                    println(&quot;GuardRepository: API returned error: $errorMessage&quot;)&#10;                    emit(Result.failure(Exception(errorMessage)))&#10;                }&#10;            } else {&#10;                // Handle HTTP error responses&#10;                val errorBody = response.errorBody()?.string()&#10;                println(&quot;GuardRepository: HTTP Error ${response.code()}: $errorBody&quot;)&#10;&#10;                val errorMessage = when (response.code()) {&#10;                    401 -&gt; &quot;Unauthorized access. Please login again&quot;&#10;                    403 -&gt; &quot;Access denied. Guard permissions required&quot;&#10;                    404 -&gt; &quot;Statistics endpoint not found&quot;&#10;                    500 -&gt; &quot;Server error. Please try again later&quot;&#10;                    else -&gt; &quot;Failed to load statistics. Please try again&quot;&#10;                }&#10;&#10;                emit(Result.failure(Exception(errorMessage)))&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;GuardRepository: Exception during stats fetch: ${e.javaClass.simpleName}: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;&#10;            val errorMessage = when (e) {&#10;                is java.net.UnknownHostException -&gt; &quot;No internet connection&quot;&#10;                is java.net.SocketTimeoutException -&gt; &quot;Connection timeout&quot;&#10;                is com.google.gson.JsonSyntaxException -&gt; &quot;Invalid response format from server&quot;&#10;                is com.google.gson.JsonParseException -&gt; &quot;Failed to parse server response&quot;&#10;                else -&gt; &quot;Network error: ${e.message ?: &quot;Unknown error&quot;}&quot;&#10;            }&#10;&#10;            emit(Result.failure(Exception(errorMessage)))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/di/NetworkModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/di/NetworkModule.kt" />
              <option name="originalContent" value="package com.example.permitely.di&#10;&#10;import android.content.Context&#10;import com.example.permitely.BuildConfig&#10;import com.example.permitely.data.network.AuthApiService&#10;import com.example.permitely.data.network.DashboardApiService&#10;import com.example.permitely.data.network.GuardApiService&#10;import com.example.permitely.data.network.ProfileApiService&#10;import com.example.permitely.data.network.VisitorApiService&#10;import com.example.permitely.data.storage.TokenStorage&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Hilt module for providing network-related dependencies&#10; */&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    /**&#10;     * Provides HTTP logging interceptor for debugging network requests&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideLoggingInterceptor(): HttpLoggingInterceptor {&#10;        return HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Provides configured OkHttp client with timeouts and logging&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(&#10;        loggingInterceptor: HttpLoggingInterceptor&#10;    ): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .addInterceptor(loggingInterceptor)&#10;            .build()&#10;    }&#10;&#10;    /**&#10;     * Provides Retrofit instance configured for the backend API&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        // Use BuildConfig if available, otherwise fallback to production URL&#10;        val baseUrl = try {&#10;            BuildConfig.BASE_URL&#10;        } catch (e: Exception) {&#10;            &quot;https://permitly-production.up.railway.app/&quot;&#10;        }&#10;&#10;        return Retrofit.Builder()&#10;            .baseUrl(baseUrl)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    /**&#10;     * Provides AuthApiService for authentication endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApiService(retrofit: Retrofit): AuthApiService {&#10;        return retrofit.create(AuthApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides DashboardApiService for dashboard endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideDashboardApiService(retrofit: Retrofit): DashboardApiService {&#10;        return retrofit.create(DashboardApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides ProfileApiService for profile endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideProfileApiService(retrofit: Retrofit): ProfileApiService {&#10;        return retrofit.create(ProfileApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides VisitorApiService for visitor endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideVisitorApiService(retrofit: Retrofit): VisitorApiService {&#10;        return retrofit.create(VisitorApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides GuardApiService for guard endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideGuardApiService(retrofit: Retrofit): GuardApiService {&#10;        return retrofit.create(GuardApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides TokenStorage for secure token management&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideTokenStorage(@ApplicationContext context: Context): TokenStorage {&#10;        return TokenStorage(context)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.di&#10;&#10;import android.content.Context&#10;import com.example.permitely.data.network.AuthApiService&#10;import com.example.permitely.data.network.DashboardApiService&#10;import com.example.permitely.data.network.GuardApiService&#10;import com.example.permitely.data.network.ProfileApiService&#10;import com.example.permitely.data.network.VisitorApiService&#10;import com.example.permitely.data.storage.TokenStorage&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Hilt module for providing network-related dependencies&#10; */&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    /**&#10;     * Provides HTTP logging interceptor for debugging network requests&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideLoggingInterceptor(): HttpLoggingInterceptor {&#10;        return HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Provides configured OkHttp client with timeouts and logging&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(&#10;        loggingInterceptor: HttpLoggingInterceptor&#10;    ): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .addInterceptor(loggingInterceptor)&#10;            .build()&#10;    }&#10;&#10;    /**&#10;     * Provides Retrofit instance configured for the backend API&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;https://permitly-production.up.railway.app/&quot;)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    /**&#10;     * Provides AuthApiService for authentication endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApiService(retrofit: Retrofit): AuthApiService {&#10;        return retrofit.create(AuthApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides DashboardApiService for dashboard endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideDashboardApiService(retrofit: Retrofit): DashboardApiService {&#10;        return retrofit.create(DashboardApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides ProfileApiService for profile endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideProfileApiService(retrofit: Retrofit): ProfileApiService {&#10;        return retrofit.create(ProfileApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides VisitorApiService for visitor endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideVisitorApiService(retrofit: Retrofit): VisitorApiService {&#10;        return retrofit.create(VisitorApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides GuardApiService for guard endpoints&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideGuardApiService(retrofit: Retrofit): GuardApiService {&#10;        return retrofit.create(GuardApiService::class.java)&#10;    }&#10;&#10;    /**&#10;     * Provides TokenStorage for secure token management&#10;     */&#10;    @Provides&#10;    @Singleton&#10;    fun provideTokenStorage(@ApplicationContext context: Context): TokenStorage {&#10;        return TokenStorage(context)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/guard/GuardDashboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/guard/GuardDashboardScreen.kt" />
              <option name="originalContent" value="package com.example.permitely.ui.guard&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.permitely.data.models.DashboardStatsUiState&#10;import com.example.permitely.ui.common.PermitelyProfileAppBar&#10;import com.example.permitely.ui.theme.*&#10;import kotlinx.coroutines.delay&#10;&#10;/**&#10; * Guard Dashboard Screen - Main landing page for guards&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GuardDashboardScreen(&#10;    onScanPass: () -&gt; Unit = {},&#10;    onCreateVisitor: () -&gt; Unit = {},&#10;    onViewNotifications: () -&gt; Unit = {},&#10;    onViewProfile: () -&gt; Unit = {},&#10;    viewModel: GuardDashboardViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()&#10;&#10;    // Show error snackbar if there's an error&#10;    if (uiState.error != null) {&#10;        LaunchedEffect(uiState.error) {&#10;            delay(3000)&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            PermitelyProfileAppBar(&#10;                title = &quot;Guard Dashboard&quot;,&#10;                subtitle = &quot;Manage visitor access&quot;,&#10;                userName = uiState.userName,&#10;                userRole = &quot;Guard&quot;,&#10;                onProfileClick = onViewProfile,&#10;                onNotificationClick = onViewNotifications,&#10;                notificationCount = 5,&#10;                scrollBehavior = scrollBehavior&#10;            )&#10;        },&#10;        content = { paddingValues -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Background)&#10;                    .padding(paddingValues)&#10;            ) {&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(24.dp)&#10;                ) {&#10;                    // Loading/Error states&#10;                    item {&#10;                        if (uiState.isLoading) {&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                colors = CardDefaults.cardColors(containerColor = Surface)&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(16.dp),&#10;                                    horizontalArrangement = Arrangement.Center,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(20.dp),&#10;                                        color = Primary,&#10;                                        strokeWidth = 2.dp&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                    Text(&#10;                                        text = &quot;Loading dashboard...&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        color = TextSecondary&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        if (uiState.error != null) {&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                colors = CardDefaults.cardColors(containerColor = ErrorLight.copy(alpha = 0.1f))&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(16.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Error,&#10;                                        contentDescription = &quot;Error&quot;,&#10;                                        tint = MaterialTheme.colorScheme.error&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                    Text(&#10;                                        text = uiState.error ?: &quot;Unknown error&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        color = MaterialTheme.colorScheme.onErrorContainer&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Quick Actions Section (Only 2 cards: Scan QR, Create Visitor)&#10;                    item {&#10;                        QuickActionsSection(&#10;                            onScanPass = onScanPass,&#10;                            onCreateVisitor = onCreateVisitor&#10;                        )&#10;                    }&#10;&#10;                    // Stats Cards Section (3 cards: Total, Approved, Pending)&#10;                    item {&#10;                        StatsSection(uiState = uiState)&#10;                    }&#10;&#10;                    // Bottom spacing&#10;                    item {&#10;                        Spacer(modifier = Modifier.height(32.dp))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;/**&#10; * Quick Actions Section - 2x2 grid of large action cards&#10; */&#10;@Composable&#10;private fun QuickActionsSection(&#10;    onScanPass: () -&gt; Unit,&#10;    onCreateVisitor: () -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;Quick Actions&quot;,&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            color = TextPrimary,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // 2x2 Grid for actions&#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // First row&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                ActionCard(&#10;                    title = &quot;Scan Pass&quot;,&#10;                    subtitle = &quot;Verify visitor passes&quot;,&#10;                    icon = Icons.Default.QrCodeScanner,&#10;                    gradient = Brush.linearGradient(&#10;                        colors = listOf(Primary, PrimaryLight)&#10;                    ),&#10;                    onClick = onScanPass,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                ActionCard(&#10;                    title = &quot;Create Visitor&quot;,&#10;                    subtitle = &quot;Add new visitor&quot;,&#10;                    icon = Icons.Default.PersonAdd,&#10;                    gradient = Brush.linearGradient(&#10;                        colors = listOf(Secondary, SecondaryLight)&#10;                    ),&#10;                    onClick = onCreateVisitor,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Stats Section - 3 stats cards showing today's visitor information (vertical layout)&#10; */&#10;@Composable&#10;private fun StatsSection(uiState: DashboardStatsUiState) {&#10;    Column {&#10;        Text(&#10;            text = &quot;Today's Stats&quot;,&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            color = TextPrimary,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Debug logging&#10;        println(&quot;StatsSection: totalVisitors = ${uiState.totalVisitors}&quot;)&#10;        println(&quot;StatsSection: approved = ${uiState.approved}&quot;)&#10;        println(&quot;StatsSection: pending = ${uiState.pending}&quot;)&#10;        println(&quot;StatsSection: totalVisitors.toString() = '${uiState.totalVisitors.toString()}'&quot;)&#10;&#10;        // 3 stats cards placed vertically (one below another)&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            StatsCard(&#10;                title = &quot;Today's Total Visitors&quot;,&#10;                value = uiState.totalVisitors.toString(),&#10;                icon = Icons.Default.People,&#10;                backgroundColor = Primary.copy(alpha = 0.1f),&#10;                iconColor = Primary,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;            StatsCard(&#10;                title = &quot;Today's Approved Visitors&quot;,&#10;                value = uiState.approved.toString(),&#10;                icon = Icons.Default.CheckCircle,&#10;                backgroundColor = Success.copy(alpha = 0.1f),&#10;                iconColor = Success,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;            StatsCard(&#10;                title = &quot;Today's Pending Visitors&quot;,&#10;                value = uiState.pending.toString(),&#10;                icon = Icons.Default.Schedule,&#10;                backgroundColor = Warning.copy(alpha = 0.1f),&#10;                iconColor = Warning,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Stats Card Component - Horizontal card for daily stats&#10; */&#10;@Composable&#10;private fun StatsCard(&#10;    title: String,&#10;    value: String,&#10;    icon: ImageVector,&#10;    backgroundColor: Color,&#10;    iconColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // Debug logging for this specific card&#10;    println(&quot;StatsCard: title='$title', value='$value', value.length=${value.length}&quot;)&#10;&#10;    Card(&#10;        modifier = modifier&#10;            .height(80.dp),&#10;        colors = CardDefaults.cardColors(containerColor = backgroundColor),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(20.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Icon(&#10;                    imageVector = icon,&#10;                    contentDescription = title,&#10;                    tint = iconColor,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;                Column {&#10;                    Text(&#10;                        text = title,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        color = TextSecondary,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = value,&#10;                        style = MaterialTheme.typography.headlineMedium,&#10;                        color = TextPrimary,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Action Card Component - Large card for quick actions&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun ActionCard(&#10;    title: String,&#10;    subtitle: String,&#10;    icon: ImageVector,&#10;    gradient: Brush,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        onClick = onClick,&#10;        modifier = modifier&#10;            .height(120.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(gradient)&#10;                .padding(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.fillMaxSize(),&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Icon(&#10;                    imageVector = icon,&#10;                    contentDescription = title,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;                Column {&#10;                    Text(&#10;                        text = title,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        color = Color.White,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Text(&#10;                        text = subtitle,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.White.copy(alpha = 0.9f)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.ui.guard&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.permitely.data.models.DashboardStatsUiState&#10;import com.example.permitely.ui.common.PermitelyProfileAppBar&#10;import com.example.permitely.ui.theme.*&#10;import kotlinx.coroutines.delay&#10;&#10;/**&#10; * Guard Dashboard Screen - Main landing page for guards&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GuardDashboardScreen(&#10;    onScanPass: () -&gt; Unit = {},&#10;    onCreateVisitor: () -&gt; Unit = {},&#10;    onViewNotifications: () -&gt; Unit = {},&#10;    onViewProfile: () -&gt; Unit = {},&#10;    viewModel: GuardDashboardViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()&#10;&#10;    // Show error snackbar if there's an error&#10;    if (uiState.error != null) {&#10;        LaunchedEffect(uiState.error) {&#10;            delay(3000)&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            PermitelyProfileAppBar(&#10;                title = &quot;Guard Dashboard&quot;,&#10;                subtitle = &quot;Manage visitor access&quot;,&#10;                userName = uiState.userName,&#10;                userRole = &quot;Guard&quot;,&#10;                onProfileClick = onViewProfile,&#10;                onNotificationClick = onViewNotifications,&#10;                notificationCount = 5,&#10;                scrollBehavior = scrollBehavior&#10;            )&#10;        },&#10;        content = { paddingValues -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Background)&#10;                    .padding(paddingValues)&#10;            ) {&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(24.dp)&#10;                ) {&#10;                    // Loading/Error states&#10;                    item {&#10;                        if (uiState.isLoading) {&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                colors = CardDefaults.cardColors(containerColor = Surface)&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(16.dp),&#10;                                    horizontalArrangement = Arrangement.Center,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(20.dp),&#10;                                        color = Primary,&#10;                                        strokeWidth = 2.dp&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                    Text(&#10;                                        text = &quot;Loading dashboard...&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        color = TextSecondary&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        if (uiState.error != null) {&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                colors = CardDefaults.cardColors(containerColor = ErrorLight.copy(alpha = 0.1f))&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(16.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Error,&#10;                                        contentDescription = &quot;Error&quot;,&#10;                                        tint = MaterialTheme.colorScheme.error&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                    Text(&#10;                                        text = uiState.error ?: &quot;Unknown error&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        color = MaterialTheme.colorScheme.onErrorContainer&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Quick Actions Section (Only 2 cards: Scan QR, Create Visitor)&#10;                    item {&#10;                        QuickActionsSection(&#10;                            onScanPass = onScanPass,&#10;                            onCreateVisitor = onCreateVisitor&#10;                        )&#10;                    }&#10;&#10;                    // Stats Cards Section (3 cards: Total, Approved, Pending)&#10;                    item {&#10;                        StatsSection(uiState = uiState)&#10;                    }&#10;&#10;                    // Bottom spacing&#10;                    item {&#10;                        Spacer(modifier = Modifier.height(32.dp))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;/**&#10; * Quick Actions Section - 2x2 grid of large action cards&#10; */&#10;@Composable&#10;private fun QuickActionsSection(&#10;    onScanPass: () -&gt; Unit,&#10;    onCreateVisitor: () -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;Quick Actions&quot;,&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            color = TextPrimary,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // 2x2 Grid for actions&#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // First row&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                ActionCard(&#10;                    title = &quot;Scan Pass&quot;,&#10;                    subtitle = &quot;Verify visitor passes&quot;,&#10;                    icon = Icons.Default.QrCodeScanner,&#10;                    gradient = Brush.linearGradient(&#10;                        colors = listOf(Primary, PrimaryLight)&#10;                    ),&#10;                    onClick = onScanPass,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                ActionCard(&#10;                    title = &quot;Create Visitor&quot;,&#10;                    subtitle = &quot;Add new visitor&quot;,&#10;                    icon = Icons.Default.PersonAdd,&#10;                    gradient = Brush.linearGradient(&#10;                        colors = listOf(Secondary, SecondaryLight)&#10;                    ),&#10;                    onClick = onCreateVisitor,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Stats Section - 3 stats cards showing today's visitor information (vertical layout)&#10; */&#10;@Composable&#10;private fun StatsSection(uiState: DashboardStatsUiState) {&#10;    Column {&#10;        Text(&#10;            text = &quot;Today's Stats&quot;,&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            color = TextPrimary,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Debug logging&#10;        println(&quot;StatsSection: totalVisitors = ${uiState.totalVisitors}&quot;)&#10;        println(&quot;StatsSection: approved = ${uiState.approved}&quot;)&#10;        println(&quot;StatsSection: pending = ${uiState.pending}&quot;)&#10;        println(&quot;StatsSection: totalVisitors.toString() = '${uiState.totalVisitors.toString()}'&quot;)&#10;&#10;        // 3 stats cards placed vertically (one below another)&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            StatsCard(&#10;                title = &quot;Today's Total Visitors&quot;,&#10;                value = uiState.totalVisitors.toString(),&#10;                icon = Icons.Default.People,&#10;                backgroundColor = Primary.copy(alpha = 0.1f),&#10;                iconColor = Primary,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;            StatsCard(&#10;                title = &quot;Today's Approved Visitors&quot;,&#10;                value = uiState.approved.toString(),&#10;                icon = Icons.Default.CheckCircle,&#10;                backgroundColor = Success.copy(alpha = 0.1f),&#10;                iconColor = Success,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;            StatsCard(&#10;                title = &quot;Today's Pending Visitors&quot;,&#10;                value = uiState.pending.toString(),&#10;                icon = Icons.Default.Schedule,&#10;                backgroundColor = Warning.copy(alpha = 0.1f),&#10;                iconColor = Warning,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Stats Card Component - Horizontal card for daily stats&#10; */&#10;@Composable&#10;private fun StatsCard(&#10;    title: String,&#10;    value: String,&#10;    icon: ImageVector,&#10;    backgroundColor: Color,&#10;    iconColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // Debug logging for this specific card&#10;    println(&quot;StatsCard: title='$title', value='$value', value.length=${value.length}&quot;)&#10;&#10;    Card(&#10;        modifier = modifier&#10;            .height(100.dp), // Increased from 80.dp to 100.dp to prevent text clipping&#10;        colors = CardDefaults.cardColors(containerColor = backgroundColor),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(20.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Icon(&#10;                    imageVector = icon,&#10;                    contentDescription = title,&#10;                    tint = iconColor,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;                Column {&#10;                    Text(&#10;                        text = title,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        color = TextSecondary,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = value,&#10;                        style = MaterialTheme.typography.headlineMedium,&#10;                        color = TextPrimary,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Action Card Component - Large card for quick actions&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun ActionCard(&#10;    title: String,&#10;    subtitle: String,&#10;    icon: ImageVector,&#10;    gradient: Brush,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        onClick = onClick,&#10;        modifier = modifier&#10;            .height(120.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(gradient)&#10;                .padding(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.fillMaxSize(),&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Icon(&#10;                    imageVector = icon,&#10;                    contentDescription = title,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;                Column {&#10;                    Text(&#10;                        text = title,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        color = Color.White,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Text(&#10;                        text = subtitle,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.White.copy(alpha = 0.9f)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/guard/GuardDashboardViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/guard/GuardDashboardViewModel.kt" />
              <option name="originalContent" value="package com.example.permitely.ui.guard&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.permitely.data.models.DashboardStatsUiState&#10;import com.example.permitely.data.repository.GuardRepository&#10;import com.example.permitely.data.storage.TokenStorage&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for Guard Dashboard Screen&#10; * Manages guard dashboard statistics and UI state with today's stats&#10; */&#10;@HiltViewModel&#10;class GuardDashboardViewModel @Inject constructor(&#10;    private val guardRepository: GuardRepository,&#10;    private val tokenStorage: TokenStorage&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(DashboardStatsUiState())&#10;    val uiState: StateFlow&lt;DashboardStatsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadDashboardData()&#10;    }&#10;&#10;    /**&#10;     * Load guard dashboard statistics and user info&#10;     */&#10;    private fun loadDashboardData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            println(&quot;GuardDashboardViewModel: Starting to load dashboard data&quot;)&#10;&#10;            // Load user info from storage (Flow-based) - but don't collect continuously&#10;            val userInfo = tokenStorage.getUserInfo().first()&#10;            _uiState.value = _uiState.value.copy(&#10;                userName = userInfo?.name ?: &quot;Guard&quot;,&#10;                userEmail = userInfo?.email ?: &quot;&quot;,&#10;                userRole = &quot;Guard&quot;&#10;            )&#10;&#10;            println(&quot;GuardDashboardViewModel: User info loaded - ${userInfo?.name}&quot;)&#10;        }&#10;&#10;        // Load today's guard stats&#10;        loadTodayStats()&#10;    }&#10;&#10;    /**&#10;     * Load today's guard statistics from the API&#10;     */&#10;    private fun loadTodayStats() {&#10;        viewModelScope.launch {&#10;            try {&#10;                guardRepository.getTodayStats().collect { result -&gt;&#10;                    result.fold(&#10;                        onSuccess = { todayStats -&gt;&#10;                            _uiState.value = _uiState.value.copy(&#10;                                totalVisitors = todayStats.totalVisitors,&#10;                                approved = todayStats.approvedVisitors,&#10;                                pending = todayStats.pendingVisitors,&#10;                                rejected = todayStats.rejectedVisitors,&#10;                                expired = todayStats.expiredVisitors,&#10;                                isLoading = false,&#10;                                error = null&#10;                            )&#10;                            println(&quot;GuardDashboardViewModel: Today's stats loaded - Total: ${todayStats.totalVisitors}&quot;)&#10;                        },&#10;                        onFailure = { error -&gt;&#10;                            _uiState.value = _uiState.value.copy(&#10;                                isLoading = false,&#10;                                error = error.message ?: &quot;Failed to load today's statistics&quot;&#10;                            )&#10;                            println(&quot;GuardDashboardViewModel: Failed to load stats - ${error.message}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = e.message ?: &quot;Failed to load dashboard data&quot;&#10;                )&#10;                println(&quot;GuardDashboardViewModel: Exception loading stats - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh dashboard data&#10;     */&#10;    fun refresh() {&#10;        loadDashboardData()&#10;    }&#10;&#10;    /**&#10;     * Clear error state&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.ui.guard&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.permitely.data.models.DashboardStatsUiState&#10;import com.example.permitely.data.repository.GuardRepository&#10;import com.example.permitely.data.storage.TokenStorage&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for Guard Dashboard Screen&#10; * Manages guard dashboard statistics and UI state with today's stats&#10; */&#10;@HiltViewModel&#10;class GuardDashboardViewModel @Inject constructor(&#10;    private val guardRepository: GuardRepository,&#10;    private val tokenStorage: TokenStorage&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(DashboardStatsUiState())&#10;    val uiState: StateFlow&lt;DashboardStatsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        println(&quot;GuardDashboardViewModel: Initializing...&quot;)&#10;        println(&quot;GuardDashboardViewModel: Initial UI State - Total: ${_uiState.value.totalVisitors}&quot;)&#10;        loadDashboardData()&#10;    }&#10;&#10;    /**&#10;     * Load guard dashboard statistics and user info&#10;     */&#10;    private fun loadDashboardData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            println(&quot;GuardDashboardViewModel: Starting to load dashboard data&quot;)&#10;&#10;            // Load user info from storage (Flow-based) - but don't collect continuously&#10;            val userInfo = tokenStorage.getUserInfo().first()&#10;            _uiState.value = _uiState.value.copy(&#10;                userName = userInfo?.name ?: &quot;Guard&quot;,&#10;                userEmail = userInfo?.email ?: &quot;&quot;,&#10;                userRole = &quot;Guard&quot;&#10;            )&#10;&#10;            println(&quot;GuardDashboardViewModel: User info loaded - ${userInfo?.name}&quot;)&#10;        }&#10;&#10;        // Load today's guard stats&#10;        loadTodayStats()&#10;    }&#10;&#10;    /**&#10;     * Load today's guard statistics from the API&#10;     */&#10;    private fun loadTodayStats() {&#10;        viewModelScope.launch {&#10;            try {&#10;                guardRepository.getTodayStats().collect { result -&gt;&#10;                    result.fold(&#10;                        onSuccess = { todayStats -&gt;&#10;                            _uiState.value = _uiState.value.copy(&#10;                                totalVisitors = todayStats.totalVisitors,&#10;                                approved = todayStats.approvedVisitors,&#10;                                pending = todayStats.pendingVisitors,&#10;                                rejected = todayStats.rejectedVisitors,&#10;                                expired = todayStats.expiredVisitors,&#10;                                isLoading = false,&#10;                                error = null&#10;                            )&#10;                            println(&quot;GuardDashboardViewModel: Today's stats loaded - Total: ${todayStats.totalVisitors}&quot;)&#10;                        },&#10;                        onFailure = { error -&gt;&#10;                            _uiState.value = _uiState.value.copy(&#10;                                isLoading = false,&#10;                                error = error.message ?: &quot;Failed to load today's statistics&quot;&#10;                            )&#10;                            println(&quot;GuardDashboardViewModel: Failed to load stats - ${error.message}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = e.message ?: &quot;Failed to load dashboard data&quot;&#10;                )&#10;                println(&quot;GuardDashboardViewModel: Exception loading stats - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh dashboard data&#10;     */&#10;    fun refresh() {&#10;        loadDashboardData()&#10;    }&#10;&#10;    /**&#10;     * Clear error state&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/guard/ScanPassScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/guard/ScanPassScreen.kt" />
              <option name="originalContent" value="package com.example.permitely.ui.guard&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.CheckCircle&#10;import androidx.compose.material.icons.filled.Error&#10;import androidx.compose.material.icons.filled.FlashlightOn&#10;import androidx.compose.material.icons.filled.FlashlightOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.BlendMode&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.camera.core.*&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.core.content.ContextCompat&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.permitely.ui.theme.*&#10;import java.util.concurrent.ExecutorService&#10;import java.util.concurrent.Executors&#10;&#10;/**&#10; * Scan Pass Screen - Full-screen camera with QR code scanning&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ScanPassScreen(&#10;    onNavigateBack: () -&gt; Unit,&#10;    onEnterManually: () -&gt; Unit,&#10;    onPassScanned: (String) -&gt; Unit,&#10;    viewModel: ScanPassViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    var isFlashlightOn by remember { mutableStateOf(false) }&#10;    var cameraProvider: ProcessCameraProvider? by remember { mutableStateOf(null) }&#10;    var camera: Camera? by remember { mutableStateOf(null) }&#10;&#10;    // Camera executor&#10;    val cameraExecutor: ExecutorService = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black)&#10;    ) {&#10;        // Camera Preview&#10;        AndroidView(&#10;            factory = { ctx -&gt;&#10;                val previewView = PreviewView(ctx)&#10;                val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)&#10;&#10;                cameraProviderFuture.addListener({&#10;                    val provider = cameraProviderFuture.get()&#10;                    cameraProvider = provider&#10;&#10;                    val preview = Preview.Builder().build()&#10;                    preview.setSurfaceProvider(previewView.surfaceProvider)&#10;&#10;                    val imageAnalyzer = ImageAnalysis.Builder()&#10;                        .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                        .build()&#10;&#10;                    // TODO: Add QR code analysis here&#10;                    // imageAnalyzer.setAnalyzer(cameraExecutor, QRCodeAnalyzer { qrCode -&gt;&#10;                    //     onPassScanned(qrCode)&#10;                    // })&#10;&#10;                    val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA&#10;&#10;                    try {&#10;                        provider.unbindAll()&#10;                        camera = provider.bindToLifecycle(&#10;                            lifecycleOwner,&#10;                            cameraSelector,&#10;                            preview,&#10;                            imageAnalyzer&#10;                        )&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                }, ContextCompat.getMainExecutor(ctx))&#10;&#10;                previewView&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;&#10;        // Scan Frame Overlay&#10;        ScanFrameOverlay(&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;&#10;        // Top Bar&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .statusBarsPadding()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Back Button&#10;            IconButton(&#10;                onClick = onNavigateBack,&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .background(&#10;                        Color.Black.copy(alpha = 0.3f),&#10;                        RoundedCornerShape(24.dp)&#10;                    )&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.ArrowBack,&#10;                    contentDescription = &quot;Back&quot;,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            // Flashlight Toggle&#10;            IconButton(&#10;                onClick = {&#10;                    isFlashlightOn = !isFlashlightOn&#10;                    camera?.cameraControl?.enableTorch(isFlashlightOn)&#10;                },&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .background(&#10;                        Color.Black.copy(alpha = 0.3f),&#10;                        RoundedCornerShape(24.dp)&#10;                    )&#10;            ) {&#10;                Icon(&#10;                    imageVector = if (isFlashlightOn) Icons.Default.FlashlightOn else Icons.Default.FlashlightOff,&#10;                    contentDescription = if (isFlashlightOn) &quot;Turn off flashlight&quot; else &quot;Turn on flashlight&quot;,&#10;                    tint = if (isFlashlightOn) Color.Yellow else Color.White,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Scan Instructions&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.Center)&#10;                .offset(y = 120.dp)&#10;                .padding(horizontal = 32.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = &quot;Position QR code within the frame&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = Color.White,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier&#10;                    .background(&#10;                        Color.Black.copy(alpha = 0.6f),&#10;                        RoundedCornerShape(8.dp)&#10;                    )&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp)&#10;            )&#10;        }&#10;&#10;        // Bottom Section with Manual Entry&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 48.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Manual Entry Button&#10;            TextButton(&#10;                onClick = onEnterManually,&#10;                modifier = Modifier&#10;                    .background(&#10;                        Color.Black.copy(alpha = 0.6f),&#10;                        RoundedCornerShape(24.dp)&#10;                    )&#10;                    .padding(horizontal = 8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Enter Pass ID manually&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = Color.White,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;            }&#10;        }&#10;&#10;        // Loading State&#10;        if (uiState.isLoading) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.7f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        color = Primary,&#10;                        modifier = Modifier.size(48.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Verifying pass...&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Scan Result Display&#10;        uiState.scanResult?.let { scanResult -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.8f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                ScanResultCard(&#10;                    scanResult = scanResult,&#10;                    onScanAgain = { viewModel.startScanningAgain() },&#10;                    onNavigateBack = onNavigateBack&#10;                )&#10;            }&#10;        }&#10;&#10;        // Error State&#10;        uiState.error?.let { error -&gt;&#10;            LaunchedEffect(error) {&#10;                // Show error for 3 seconds then allow scanning again&#10;                kotlinx.coroutines.delay(3000)&#10;                viewModel.clearError()&#10;                viewModel.startScanningAgain()&#10;            }&#10;&#10;            Card(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .padding(top = 100.dp, horizontal = 16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = Color.Red.copy(alpha = 0.9f))&#10;            ) {&#10;                Text(&#10;                    text = error,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = Color.White,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;&#10;        // Handle QR code scanning when camera is ready and scanning is active&#10;        LaunchedEffect(uiState.isScanning) {&#10;            if (uiState.isScanning) {&#10;                // Simulate QR code scan for demo - replace with actual QR scanner&#10;                // For now, you can test with a sample QR code&#10;                // viewModel.onQRCodeScanned(&quot;https://yourbackend.com/api/guard/scan/789&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Scan Result Card - Shows pass verification results&#10; */&#10;@Composable&#10;private fun ScanResultCard(&#10;    scanResult: com.example.permitely.data.models.PassScanResult,&#10;    onScanAgain: () -&gt; Unit,&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (scanResult.isSuccess) Success.copy(alpha = 0.95f) else Color.Red.copy(alpha = 0.95f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(24.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Status Icon and Title&#10;            Icon(&#10;                imageVector = if (scanResult.isSuccess) Icons.Default.CheckCircle else Icons.Default.Error,&#10;                contentDescription = null,&#10;                tint = Color.White,&#10;                modifier = Modifier.size(48.dp)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Text(&#10;                text = if (scanResult.isSuccess) &quot;Pass Verified Successfully!&quot; else &quot;Verification Failed&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                color = Color.White,&#10;                fontWeight = FontWeight.Bold,&#10;                textAlign = TextAlign.Center&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            if (scanResult.isSuccess &amp;&amp; scanResult.visitor != null &amp;&amp; scanResult.pass != null) {&#10;                // Show visitor details for successful scan&#10;                VisitorDetailsSection(&#10;                    visitor = scanResult.visitor,&#10;                    pass = scanResult.pass&#10;                )&#10;            } else {&#10;                // Show error message&#10;                Text(&#10;                    text = scanResult.errorMessage ?: &quot;Unknown error occurred&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = Color.White,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Action Buttons&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                OutlinedButton(&#10;                    onClick = onNavigateBack,&#10;                    modifier = Modifier.weight(1f),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        contentColor = Color.White&#10;                    ),&#10;                    border = androidx.compose.foundation.BorderStroke(1.dp, Color.White)&#10;                ) {&#10;                    Text(&quot;Done&quot;)&#10;                }&#10;&#10;                Button(&#10;                    onClick = onScanAgain,&#10;                    modifier = Modifier.weight(1f),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color.White,&#10;                        contentColor = if (scanResult.isSuccess) Success else Color.Red&#10;                    )&#10;                ) {&#10;                    Text(&quot;Scan Again&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Visitor Details Section for successful scan&#10; */&#10;@Composable&#10;private fun VisitorDetailsSection(&#10;    visitor: com.example.permitely.data.models.VisitorScanData,&#10;    pass: com.example.permitely.data.models.PassScanData&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;Visitor Information&quot;,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = Color.White,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;&#10;        DetailRow(&quot;Name&quot;, visitor.name)&#10;        DetailRow(&quot;Email&quot;, visitor.email)&#10;        DetailRow(&quot;Phone&quot;, visitor.phoneNumber)&#10;        DetailRow(&quot;Purpose&quot;, visitor.purposeOfVisit)&#10;        DetailRow(&quot;Status&quot;, visitor.status)&#10;&#10;        if (pass.expiryTime.isNotEmpty()) {&#10;            DetailRow(&quot;Pass Expires&quot;, formatDateTime(pass.expiryTime))&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Detail Row for visitor information&#10; */&#10;@Composable&#10;private fun DetailRow(label: String, value: String) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        horizontalArrangement = Arrangement.SpaceBetween&#10;    ) {&#10;        Text(&#10;            text = &quot;$label:&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = Color.White.copy(alpha = 0.8f),&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;        Text(&#10;            text = value,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = Color.White,&#10;            fontWeight = FontWeight.Medium,&#10;            modifier = Modifier.weight(1f),&#10;            textAlign = TextAlign.End&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Format ISO datetime string for display&#10; */&#10;private fun formatDateTime(isoString: String): String {&#10;    return try {&#10;        // Simple formatting - you can enhance this with proper date formatting&#10;        isoString.substring(0, 16).replace(&quot;T&quot;, &quot; &quot;)&#10;    } catch (e: Exception) {&#10;        isoString&#10;    }&#10;}&#10;&#10;/**&#10; * Scan Frame Overlay - Custom composable to draw the scanning frame overlay&#10; */&#10;@Composable&#10;fun ScanFrameOverlay(modifier: Modifier = Modifier) {&#10;    val density = LocalDensity.current&#10;    &#10;    Box(modifier = modifier) {&#10;        // Center scanning area with transparent overlay&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            val frameSize = size.width * 0.7f&#10;            val frameLeft = (size.width - frameSize) / 2&#10;            val frameTop = (size.height - frameSize) / 2&#10;            val strokeWidth = with(density) { 4.dp.toPx() }&#10;            &#10;            // Draw semi-transparent overlay&#10;            drawRect(&#10;                color = Color.Black.copy(alpha = 0.5f),&#10;                size = Size(size.width, frameTop)&#10;            )&#10;            drawRect(&#10;                color = Color.Black.copy(alpha = 0.5f),&#10;                topLeft = Offset(0f, frameTop + frameSize),&#10;                size = Size(size.width, size.height - frameTop - frameSize)&#10;            )&#10;            drawRect(&#10;                color = Color.Black.copy(alpha = 0.5f),&#10;                topLeft = Offset(0f, frameTop),&#10;                size = Size(frameLeft, frameSize)&#10;            )&#10;            drawRect(&#10;                color = Color.Black.copy(alpha = 0.5f),&#10;                topLeft = Offset(frameLeft + frameSize, frameTop),&#10;                size = Size(size.width - frameLeft - frameSize, frameSize)&#10;            )&#10;            &#10;            // Draw frame corners&#10;            val cornerLength = with(density) { 24.dp.toPx() }&#10;            val frameColor = Primary&#10;            &#10;            // Top-left corner&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft, frameTop),&#10;                size = Size(cornerLength, strokeWidth)&#10;            )&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft, frameTop),&#10;                size = Size(strokeWidth, cornerLength)&#10;            )&#10;            &#10;            // Top-right corner&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft + frameSize - cornerLength, frameTop),&#10;                size = Size(cornerLength, strokeWidth)&#10;            )&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft + frameSize - strokeWidth, frameTop),&#10;                size = Size(strokeWidth, cornerLength)&#10;            )&#10;            &#10;            // Bottom-left corner&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft, frameTop + frameSize - strokeWidth),&#10;                size = Size(cornerLength, strokeWidth)&#10;            )&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft, frameTop + frameSize - cornerLength),&#10;                size = Size(strokeWidth, cornerLength)&#10;            )&#10;            &#10;            // Bottom-right corner&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft + frameSize - cornerLength, frameTop + frameSize - strokeWidth),&#10;                size = Size(cornerLength, strokeWidth)&#10;            )&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft + frameSize - strokeWidth, frameTop + frameSize - cornerLength),&#10;                size = Size(strokeWidth, cornerLength)&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.ui.guard&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.CheckCircle&#10;import androidx.compose.material.icons.filled.Error&#10;import androidx.compose.material.icons.filled.FlashlightOn&#10;import androidx.compose.material.icons.filled.FlashlightOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.BlendMode&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.camera.core.*&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.core.content.ContextCompat&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.permitely.ui.theme.*&#10;import java.util.concurrent.ExecutorService&#10;import java.util.concurrent.Executors&#10;&#10;/**&#10; * Scan Pass Screen - Full-screen camera with QR code scanning&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ScanPassScreen(&#10;    onNavigateBack: () -&gt; Unit,&#10;    onEnterManually: () -&gt; Unit,&#10;    onPassScanned: (String) -&gt; Unit,&#10;    viewModel: ScanPassViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    var isFlashlightOn by remember { mutableStateOf(false) }&#10;    var cameraProvider: ProcessCameraProvider? by remember { mutableStateOf(null) }&#10;    var camera: Camera? by remember { mutableStateOf(null) }&#10;&#10;    // Camera executor&#10;    val cameraExecutor: ExecutorService = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black)&#10;    ) {&#10;        // Camera Preview&#10;        AndroidView(&#10;            factory = { ctx -&gt;&#10;                val previewView = PreviewView(ctx)&#10;                val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)&#10;&#10;                cameraProviderFuture.addListener({&#10;                    val provider = cameraProviderFuture.get()&#10;                    cameraProvider = provider&#10;&#10;                    val preview = Preview.Builder().build()&#10;                    preview.setSurfaceProvider(previewView.surfaceProvider)&#10;&#10;                    val imageAnalyzer = ImageAnalysis.Builder()&#10;                        .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                        .build()&#10;&#10;                    // TODO: Add QR code analysis here&#10;                    // imageAnalyzer.setAnalyzer(cameraExecutor, QRCodeAnalyzer { qrCode -&gt;&#10;                    //     onPassScanned(qrCode)&#10;                    // })&#10;&#10;                    val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA&#10;&#10;                    try {&#10;                        provider.unbindAll()&#10;                        camera = provider.bindToLifecycle(&#10;                            lifecycleOwner,&#10;                            cameraSelector,&#10;                            preview,&#10;                            imageAnalyzer&#10;                        )&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                }, ContextCompat.getMainExecutor(ctx))&#10;&#10;                previewView&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;&#10;        // Scan Frame Overlay&#10;        ScanFrameOverlay(&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;&#10;        // Top Bar&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .statusBarsPadding()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Back Button&#10;            IconButton(&#10;                onClick = onNavigateBack,&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .background(&#10;                        Color.Black.copy(alpha = 0.3f),&#10;                        RoundedCornerShape(24.dp)&#10;                    )&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.ArrowBack,&#10;                    contentDescription = &quot;Back&quot;,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            // Flashlight Toggle&#10;            IconButton(&#10;                onClick = {&#10;                    isFlashlightOn = !isFlashlightOn&#10;                    camera?.cameraControl?.enableTorch(isFlashlightOn)&#10;                },&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .background(&#10;                        Color.Black.copy(alpha = 0.3f),&#10;                        RoundedCornerShape(24.dp)&#10;                    )&#10;            ) {&#10;                Icon(&#10;                    imageVector = if (isFlashlightOn) Icons.Default.FlashlightOn else Icons.Default.FlashlightOff,&#10;                    contentDescription = if (isFlashlightOn) &quot;Turn off flashlight&quot; else &quot;Turn on flashlight&quot;,&#10;                    tint = if (isFlashlightOn) Color.Yellow else Color.White,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Scan Instructions&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.Center)&#10;                .offset(y = 120.dp)&#10;                .padding(horizontal = 32.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = &quot;Position QR code within the frame&quot;,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = Color.White,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier&#10;                    .background(&#10;                        Color.Black.copy(alpha = 0.6f),&#10;                        RoundedCornerShape(8.dp)&#10;                    )&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp)&#10;            )&#10;        }&#10;&#10;        // Bottom Section with Manual Entry&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 48.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Manual Entry Button&#10;            TextButton(&#10;                onClick = onEnterManually,&#10;                modifier = Modifier&#10;                    .background(&#10;                        Color.Black.copy(alpha = 0.6f),&#10;                        RoundedCornerShape(24.dp)&#10;                    )&#10;                    .padding(horizontal = 8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Enter Pass ID manually&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = Color.White,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;            }&#10;        }&#10;&#10;        // Loading State&#10;        if (uiState.isLoading) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.7f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        color = Primary,&#10;                        modifier = Modifier.size(48.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Verifying pass...&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Scan Result Display&#10;        uiState.scanResult?.let { scanResult -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.8f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                ScanResultCard(&#10;                    scanResult = scanResult,&#10;                    onScanAgain = { viewModel.startScanningAgain() },&#10;                    onNavigateBack = onNavigateBack&#10;                )&#10;            }&#10;        }&#10;&#10;        // Error State&#10;        uiState.error?.let { error -&gt;&#10;            LaunchedEffect(error) {&#10;                // Show error for 3 seconds then allow scanning again&#10;                kotlinx.coroutines.delay(3000)&#10;                viewModel.clearError()&#10;                viewModel.startScanningAgain()&#10;            }&#10;&#10;            Card(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .padding(start = 16.dp, top = 100.dp, end = 16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = Color.Red.copy(alpha = 0.9f))&#10;            ) {&#10;                Text(&#10;                    text = error,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = Color.White,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;&#10;        // Handle QR code scanning when camera is ready and scanning is active&#10;        LaunchedEffect(uiState.isScanning) {&#10;            if (uiState.isScanning) {&#10;                // Simulate QR code scan for demo - replace with actual QR scanner&#10;                // For now, you can test with a sample QR code&#10;                // viewModel.onQRCodeScanned(&quot;https://yourbackend.com/api/guard/scan/789&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Scan Result Card - Shows pass verification results&#10; */&#10;@Composable&#10;private fun ScanResultCard(&#10;    scanResult: com.example.permitely.data.models.PassScanResult,&#10;    onScanAgain: () -&gt; Unit,&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (scanResult.isSuccess) Success.copy(alpha = 0.95f) else Color.Red.copy(alpha = 0.95f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(24.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Status Icon and Title&#10;            Icon(&#10;                imageVector = if (scanResult.isSuccess) Icons.Default.CheckCircle else Icons.Default.Error,&#10;                contentDescription = null,&#10;                tint = Color.White,&#10;                modifier = Modifier.size(48.dp)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Text(&#10;                text = if (scanResult.isSuccess) &quot;Pass Verified Successfully!&quot; else &quot;Verification Failed&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                color = Color.White,&#10;                fontWeight = FontWeight.Bold,&#10;                textAlign = TextAlign.Center&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            if (scanResult.isSuccess &amp;&amp; scanResult.visitor != null &amp;&amp; scanResult.pass != null) {&#10;                // Show visitor details for successful scan&#10;                VisitorDetailsSection(&#10;                    visitor = scanResult.visitor,&#10;                    pass = scanResult.pass&#10;                )&#10;            } else {&#10;                // Show error message&#10;                Text(&#10;                    text = scanResult.errorMessage ?: &quot;Unknown error occurred&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = Color.White,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Action Buttons&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                OutlinedButton(&#10;                    onClick = onNavigateBack,&#10;                    modifier = Modifier.weight(1f),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        contentColor = Color.White&#10;                    ),&#10;                    border = androidx.compose.foundation.BorderStroke(1.dp, Color.White)&#10;                ) {&#10;                    Text(&quot;Done&quot;)&#10;                }&#10;&#10;                Button(&#10;                    onClick = onScanAgain,&#10;                    modifier = Modifier.weight(1f),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color.White,&#10;                        contentColor = if (scanResult.isSuccess) Success else Color.Red&#10;                    )&#10;                ) {&#10;                    Text(&quot;Scan Again&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Visitor Details Section for successful scan&#10; */&#10;@Composable&#10;private fun VisitorDetailsSection(&#10;    visitor: com.example.permitely.data.models.VisitorScanData,&#10;    pass: com.example.permitely.data.models.PassScanData&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;Visitor Information&quot;,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = Color.White,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;&#10;        DetailRow(&quot;Name&quot;, visitor.name)&#10;        DetailRow(&quot;Email&quot;, visitor.email)&#10;        DetailRow(&quot;Phone&quot;, visitor.phoneNumber)&#10;        DetailRow(&quot;Purpose&quot;, visitor.purposeOfVisit)&#10;        DetailRow(&quot;Status&quot;, visitor.status)&#10;&#10;        if (pass.expiryTime.isNotEmpty()) {&#10;            DetailRow(&quot;Pass Expires&quot;, formatDateTime(pass.expiryTime))&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Detail Row for visitor information&#10; */&#10;@Composable&#10;private fun DetailRow(label: String, value: String) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        horizontalArrangement = Arrangement.SpaceBetween&#10;    ) {&#10;        Text(&#10;            text = &quot;$label:&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = Color.White.copy(alpha = 0.8f),&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;        Text(&#10;            text = value,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = Color.White,&#10;            fontWeight = FontWeight.Medium,&#10;            modifier = Modifier.weight(1f),&#10;            textAlign = TextAlign.End&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Format ISO datetime string for display&#10; */&#10;private fun formatDateTime(isoString: String): String {&#10;    return try {&#10;        // Simple formatting - you can enhance this with proper date formatting&#10;        isoString.substring(0, 16).replace(&quot;T&quot;, &quot; &quot;)&#10;    } catch (e: Exception) {&#10;        isoString&#10;    }&#10;}&#10;&#10;/**&#10; * Scan Frame Overlay - Custom composable to draw the scanning frame overlay&#10; */&#10;@Composable&#10;fun ScanFrameOverlay(modifier: Modifier = Modifier) {&#10;    val density = LocalDensity.current&#10;    &#10;    Box(modifier = modifier) {&#10;        // Center scanning area with transparent overlay&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            val frameSize = size.width * 0.7f&#10;            val frameLeft = (size.width - frameSize) / 2&#10;            val frameTop = (size.height - frameSize) / 2&#10;            val strokeWidth = with(density) { 4.dp.toPx() }&#10;            &#10;            // Draw semi-transparent overlay&#10;            drawRect(&#10;                color = Color.Black.copy(alpha = 0.5f),&#10;                size = Size(size.width, frameTop)&#10;            )&#10;            drawRect(&#10;                color = Color.Black.copy(alpha = 0.5f),&#10;                topLeft = Offset(0f, frameTop + frameSize),&#10;                size = Size(size.width, size.height - frameTop - frameSize)&#10;            )&#10;            drawRect(&#10;                color = Color.Black.copy(alpha = 0.5f),&#10;                topLeft = Offset(0f, frameTop),&#10;                size = Size(frameLeft, frameSize)&#10;            )&#10;            drawRect(&#10;                color = Color.Black.copy(alpha = 0.5f),&#10;                topLeft = Offset(frameLeft + frameSize, frameTop),&#10;                size = Size(size.width - frameLeft - frameSize, frameSize)&#10;            )&#10;            &#10;            // Draw frame corners&#10;            val cornerLength = with(density) { 24.dp.toPx() }&#10;            val frameColor = Primary&#10;            &#10;            // Top-left corner&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft, frameTop),&#10;                size = Size(cornerLength, strokeWidth)&#10;            )&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft, frameTop),&#10;                size = Size(strokeWidth, cornerLength)&#10;            )&#10;            &#10;            // Top-right corner&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft + frameSize - cornerLength, frameTop),&#10;                size = Size(cornerLength, strokeWidth)&#10;            )&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft + frameSize - strokeWidth, frameTop),&#10;                size = Size(strokeWidth, cornerLength)&#10;            )&#10;            &#10;            // Bottom-left corner&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft, frameTop + frameSize - strokeWidth),&#10;                size = Size(cornerLength, strokeWidth)&#10;            )&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft, frameTop + frameSize - cornerLength),&#10;                size = Size(strokeWidth, cornerLength)&#10;            )&#10;            &#10;            // Bottom-right corner&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft + frameSize - cornerLength, frameTop + frameSize - strokeWidth),&#10;                size = Size(cornerLength, strokeWidth)&#10;            )&#10;            drawRect(&#10;                color = frameColor,&#10;                topLeft = Offset(frameLeft + frameSize - strokeWidth, frameTop + frameSize - cornerLength),&#10;                size = Size(strokeWidth, cornerLength)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/guard/ScanPassViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/guard/ScanPassViewModel.kt" />
              <option name="originalContent" value="package com.example.permitely.ui.guard&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * UI State for Scan Pass Screen&#10; */&#10;data class ScanPassUiState(&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val scanResult: String? = null,&#10;    val isScanning: Boolean = true&#10;)&#10;&#10;/**&#10; * ViewModel for Scan Pass Screen&#10; * Handles QR code scanning and pass verification&#10; */&#10;@HiltViewModel&#10;class ScanPassViewModel @Inject constructor(&#10;    // TODO: Inject pass verification repository when available&#10;    // private val passRepository: PassRepository&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(ScanPassUiState())&#10;    val uiState: StateFlow&lt;ScanPassUiState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Process scanned QR code&#10;     */&#10;    fun onQRCodeScanned(qrCode: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                isLoading = true,&#10;                error = null,&#10;                isScanning = false&#10;            )&#10;&#10;            try {&#10;                // TODO: Implement actual pass verification with backend&#10;                // val result = passRepository.verifyPass(qrCode)&#10;&#10;                // Simulate API call for now&#10;                kotlinx.coroutines.delay(1500)&#10;&#10;                // Mock validation - in real implementation, verify with backend&#10;                if (qrCode.isNotEmpty() &amp;&amp; qrCode.length &gt;= 6) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        scanResult = qrCode,&#10;                        error = null&#10;                    )&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Invalid QR code format&quot;,&#10;                        isScanning = true&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = e.message ?: &quot;Failed to verify pass&quot;,&#10;                    isScanning = true&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Process manually entered pass ID&#10;     */&#10;    fun onManualPassIdEntered(passId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                isLoading = true,&#10;                error = null&#10;            )&#10;&#10;            try {&#10;                // TODO: Implement actual pass verification with backend&#10;                // val result = passRepository.verifyPassById(passId)&#10;&#10;                // Simulate API call for now&#10;                kotlinx.coroutines.delay(1500)&#10;&#10;                // Mock validation - in real implementation, verify with backend&#10;                if (passId.isNotEmpty() &amp;&amp; passId.length &gt;= 4) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        scanResult = passId,&#10;                        error = null&#10;                    )&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Invalid Pass ID format&quot;&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = e.message ?: &quot;Failed to verify pass&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear error state&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    /**&#10;     * Reset scanning state&#10;     */&#10;    fun resetScanning() {&#10;        _uiState.value = _uiState.value.copy(&#10;            isScanning = true,&#10;            scanResult = null,&#10;            error = null,&#10;            isLoading = false&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Clear scan result&#10;     */&#10;    fun clearScanResult() {&#10;        _uiState.value = _uiState.value.copy(&#10;            scanResult = null,&#10;            isScanning = true&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.ui.guard&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.example.permitely.data.models.PassScanResult&#13;&#10;import com.example.permitely.data.repository.GuardRepository&#13;&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import javax.inject.Inject&#13;&#10;&#13;&#10;/**&#13;&#10; * UI State for Scan Pass Screen&#13;&#10; */&#13;&#10;data class ScanPassUiState(&#13;&#10;    val isLoading: Boolean = false,&#13;&#10;    val error: String? = null,&#13;&#10;    val scanResult: PassScanResult? = null,&#13;&#10;    val isScanning: Boolean = true,&#13;&#10;    val lastScannedCode: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;/**&#13;&#10; * ViewModel for Scan Pass Screen&#13;&#10; * Handles QR code scanning and pass verification with backend integration&#13;&#10; */&#13;&#10;@HiltViewModel&#13;&#10;class ScanPassViewModel @Inject constructor(&#13;&#10;    private val guardRepository: GuardRepository&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(ScanPassUiState())&#13;&#10;    val uiState: StateFlow&lt;ScanPassUiState&gt; = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Process scanned QR code and verify pass with backend&#13;&#10;     */&#13;&#10;    fun onQRCodeScanned(qrCode: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(&#13;&#10;                isLoading = true,&#13;&#10;                error = null,&#13;&#10;                isScanning = false,&#13;&#10;                lastScannedCode = qrCode&#13;&#10;            )&#13;&#10;&#13;&#10;            try {&#13;&#10;                println(&quot;ScanPassViewModel: Processing QR code: $qrCode&quot;)&#13;&#10;&#13;&#10;                // Extract pass ID from QR code URL&#13;&#10;                val passId = guardRepository.extractPassIdFromQrCode(qrCode)&#13;&#10;&#13;&#10;                if (passId == null) {&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        error = &quot;Invalid QR code format. Please scan a valid visitor pass.&quot;,&#13;&#10;                        scanResult = null&#13;&#10;                    )&#13;&#10;                    return@launch&#13;&#10;                }&#13;&#10;&#13;&#10;                println(&quot;ScanPassViewModel: Extracted pass ID: $passId&quot;)&#13;&#10;&#13;&#10;                // Scan the pass using the repository&#13;&#10;                guardRepository.scanPass(passId).collect { result -&gt;&#13;&#10;                    result.fold(&#13;&#10;                        onSuccess = { scanResult -&gt;&#13;&#10;                            _uiState.value = _uiState.value.copy(&#13;&#10;                                isLoading = false,&#13;&#10;                                error = if (!scanResult.isSuccess) scanResult.errorMessage else null,&#13;&#10;                                scanResult = scanResult&#13;&#10;                            )&#13;&#10;                        },&#13;&#10;                        onFailure = { error -&gt;&#13;&#10;                            _uiState.value = _uiState.value.copy(&#13;&#10;                                isLoading = false,&#13;&#10;                                error = error.message ?: &quot;Failed to scan pass&quot;,&#13;&#10;                                scanResult = null&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                println(&quot;ScanPassViewModel: Exception during QR processing: ${e.message}&quot;)&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    error = &quot;Failed to process QR code: ${e.message}&quot;,&#13;&#10;                    scanResult = null&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Reset scan state to allow scanning again&#13;&#10;     */&#13;&#10;    fun resetScan() {&#13;&#10;        _uiState.value = ScanPassUiState(isScanning = true)&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Clear error state&#13;&#10;     */&#13;&#10;    fun clearError() {&#13;&#10;        _uiState.value = _uiState.value.copy(error = null)&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start scanning again after showing results&#13;&#10;     */&#13;&#10;    fun startScanningAgain() {&#13;&#10;        _uiState.value = _uiState.value.copy(&#13;&#10;            isScanning = true,&#13;&#10;            scanResult = null,&#13;&#10;            error = null,&#13;&#10;            lastScannedCode = null&#13;&#10;        )&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/host/HostDashboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/host/HostDashboardScreen.kt" />
              <option name="originalContent" value="package com.example.permitely.ui.host&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.nestedscroll.nestedScroll&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.permitely.data.models.DashboardStatsUiState&#10;import com.example.permitely.data.models.RecentVisitor&#10;import com.example.permitely.ui.common.PermitelyProfileAppBar&#10;import com.example.permitely.ui.theme.*&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Host Dashboard Screen - Main landing page for hosts&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HostDashboardScreen(&#10;    onCreateVisitor: () -&gt; Unit = {},&#10;    onViewAllVisitors: () -&gt; Unit = {},&#10;    onViewNotifications: () -&gt; Unit = {},&#10;    onViewProfile: () -&gt; Unit = {},&#10;    onLogout: () -&gt; Unit = {},&#10;    viewModel: HostDashboardViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val recentVisitors by viewModel.recentVisitors.collectAsStateWithLifecycle()&#10;    val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            PermitelyProfileAppBar(&#10;                title = &quot;Dashboard&quot;,&#10;                subtitle = &quot;&quot;,&#10;                userName = uiState.userName,&#10;                userRole = &quot;Host&quot;,&#10;                onProfileClick = onViewProfile,&#10;                onNotificationClick = onViewNotifications,&#10;                notificationCount = 3,&#10;                scrollBehavior = scrollBehavior&#10;            )&#10;        },&#10;        content = { paddingValues -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Background)&#10;                    .padding(paddingValues)&#10;            ) {&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    // Dashboard Stats&#10;                    item {&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = CardDefaults.cardColors(containerColor = Surface)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Statistics&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium,&#10;                                    fontWeight = FontWeight.SemiBold&#10;                                )&#10;                                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                                if (uiState.isLoading) {&#10;                                    CircularProgressIndicator()&#10;                                } else if (uiState.error != null) {&#10;                                    Text(&#10;                                        text = uiState.error,&#10;                                        color = MaterialTheme.colorScheme.error&#10;                                    )&#10;                                } else {&#10;                                    Text(&quot;Total: ${uiState.totalVisitors}&quot;)&#10;                                    Text(&quot;Pending: ${uiState.pending}&quot;)&#10;                                    Text(&quot;Approved: ${uiState.approved}&quot;)&#10;                                    Text(&quot;Rejected: ${uiState.rejected}&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Recent Visitors - Simple List&#10;                    item {&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = CardDefaults.cardColors(containerColor = Surface)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Recent Visitors&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium,&#10;                                    fontWeight = FontWeight.SemiBold&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                if (recentVisitors.isEmpty()) {&#10;                                    Text(&quot;No recent visitors&quot;)&#10;                                } else {&#10;                                    recentVisitors.forEach { visitor -&gt;&#10;                                        Text(&quot;${visitor.name} - ${visitor.status}&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.permitely.ui.host&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.nestedscroll.nestedScroll&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.permitely.data.models.DashboardStatsUiState&#10;import com.example.permitely.data.models.RecentVisitor&#10;import com.example.permitely.ui.common.PermitelyProfileAppBar&#10;import com.example.permitely.ui.theme.*&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Host Dashboard Screen - Main landing page for hosts&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HostDashboardScreen(&#10;    onCreateVisitor: () -&gt; Unit = {},&#10;    onViewAllVisitors: () -&gt; Unit = {},&#10;    onViewNotifications: () -&gt; Unit = {},&#10;    onViewProfile: () -&gt; Unit = {},&#10;    onLogout: () -&gt; Unit = {},&#10;    viewModel: HostDashboardViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val recentVisitors by viewModel.recentVisitors.collectAsStateWithLifecycle()&#10;    val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            PermitelyProfileAppBar(&#10;                title = &quot;Dashboard&quot;,&#10;                subtitle = &quot;&quot;,&#10;                userName = uiState.userName,&#10;                userRole = &quot;Host&quot;,&#10;                onProfileClick = onViewProfile,&#10;                onNotificationClick = onViewNotifications,&#10;                notificationCount = 3,&#10;                scrollBehavior = scrollBehavior&#10;            )&#10;        },&#10;        content = { paddingValues -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Background)&#10;                    .padding(paddingValues)&#10;            ) {&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    // Dashboard Stats&#10;                    item {&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = CardDefaults.cardColors(containerColor = Surface)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Statistics&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium,&#10;                                    fontWeight = FontWeight.SemiBold&#10;                                )&#10;                                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                                if (uiState.isLoading) {&#10;                                    CircularProgressIndicator()&#10;                                } else {&#10;                                    val errorMessage = uiState.error&#10;                                    if (errorMessage != null) {&#10;                                        Text(&#10;                                            text = errorMessage,&#10;                                            color = MaterialTheme.colorScheme.error&#10;                                        )&#10;                                    } else {&#10;                                        Text(&quot;Total: ${uiState.totalVisitors}&quot;)&#10;                                        Text(&quot;Pending: ${uiState.pending}&quot;)&#10;                                        Text(&quot;Approved: ${uiState.approved}&quot;)&#10;                                        Text(&quot;Rejected: ${uiState.rejected}&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Recent Visitors - Simple List&#10;                    item {&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = CardDefaults.cardColors(containerColor = Surface)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Recent Visitors&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium,&#10;                                    fontWeight = FontWeight.SemiBold&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                if (recentVisitors.isEmpty()) {&#10;                                    Text(&quot;No recent visitors&quot;)&#10;                                } else {&#10;                                    recentVisitors.forEach { visitor -&gt;&#10;                                        Text(&quot;${visitor.name} - ${visitor.status}&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/host/HostDashboardViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/permitely/ui/host/HostDashboardViewModel.kt" />
              <option name="originalContent" value="package com.example.permitely.ui.host&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.permitely.data.models.DashboardStatsUiState&#10;import com.example.permitely.data.repository.DashboardRepository&#10;import com.example.permitely.data.repository.VisitorRepository&#10;import com.example.permitely.data.storage.TokenStorage&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for Host Dashboard Screen&#10; * Manages dashboard statistics and UI state&#10; */&#10;@HiltViewModel&#10;class HostDashboardViewModel @Inject constructor(&#10;    private val dashboardRepository: DashboardRepository,&#10;    private val visitorRepository: VisitorRepository,&#10;    private val tokenStorage: TokenStorage&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(DashboardStatsUiState())&#10;    val uiState: StateFlow&lt;DashboardStatsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Recent visitors state&#10;    private val _recentVisitors = MutableStateFlow&lt;List&lt;RecentVisitor&gt;&gt;(emptyList())&#10;    val recentVisitors: StateFlow&lt;List&lt;RecentVisitor&gt;&gt; = _recentVisitors.asStateFlow()&#10;&#10;    private val _isLoadingVisitors = MutableStateFlow(false)&#10;    val isLoadingVisitors: StateFlow&lt;Boolean&gt; = _isLoadingVisitors.asStateFlow()&#10;&#10;    init {&#10;        loadDashboardData()&#10;        loadRecentVisitors()&#10;    }&#10;&#10;    /**&#10;     * Load dashboard statistics and user info from the API and storage&#10;     */&#10;    private fun loadDashboardData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            // Load user name from profile API (fresh data)&#10;            dashboardRepository.getUserName().collect { nameResult -&gt;&#10;                nameResult.fold(&#10;                    onSuccess = { userName -&gt;&#10;                        _uiState.value = _uiState.value.copy(userName = userName)&#10;                    },&#10;                    onFailure = { /* Keep existing name or use default */ }&#10;                )&#10;            }&#10;        }&#10;&#10;        // Load dashboard stats separately&#10;        loadDashboardStats()&#10;    }&#10;&#10;    /**&#10;     * Load dashboard statistics from the API&#10;     */&#10;    private fun loadDashboardStats() {&#10;        viewModelScope.launch {&#10;            dashboardRepository.getDashboardStats().collect { result -&gt;&#10;                result.fold(&#10;                    onSuccess = { stats -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            totalVisitors = stats.totalVisitors,&#10;                            approved = stats.approved,&#10;                            pending = stats.pending,&#10;                            rejected = stats.rejected,&#10;                            expired = stats.expired,&#10;                            isLoading = false,&#10;                            error = null&#10;                        )&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isLoading = false,&#10;                            error = exception.message ?: &quot;Unknown error occurred&quot;&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load recent visitors from the API&#10;     */&#10;    private fun loadRecentVisitors() {&#10;        viewModelScope.launch {&#10;            _isLoadingVisitors.value = true&#10;            visitorRepository.getRecentVisitors().collect { result -&gt;&#10;                result.fold(&#10;                    onSuccess = { visitors -&gt;&#10;                        // Convert API visitors to UI visitors (only need name, purpose, time, status)&#10;                        val recentVisitors = visitors.map { apiVisitor -&gt;&#10;                            RecentVisitor(&#10;                                name = apiVisitor.name,&#10;                                purpose = apiVisitor.purposeOfVisit,&#10;                                time = formatTime(apiVisitor.createdAt),&#10;                                status = apiVisitor.status&#10;                            )&#10;                        }&#10;                        _recentVisitors.value = recentVisitors&#10;                        println(&quot;DEBUG: Loaded ${recentVisitors.size} recent visitors&quot;)&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        println(&quot;DEBUG: Failed to load recent visitors: ${exception.message}&quot;)&#10;                        // Keep empty list on error&#10;                        _recentVisitors.value = emptyList()&#10;                    }&#10;                )&#10;                _isLoadingVisitors.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh recent visitors&#10;     */&#10;    fun refreshRecentVisitors() {&#10;        loadRecentVisitors()&#10;    }&#10;&#10;    /**&#10;     * Refresh dashboard statistics&#10;     */&#10;    fun refresh() {&#10;        loadDashboardData()&#10;    }&#10;&#10;    /**&#10;     * Clear error state&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    /**&#10;     * Format timestamp to readable time&#10;     */&#10;    private fun formatTime(timestamp: String): String {&#10;        return try {&#10;            // Extract time from ISO timestamp: &quot;2025-08-10T08:00:00Z&quot; -&gt; &quot;08:00&quot;&#10;            timestamp.split(&quot;T&quot;)[1].split(&quot;Z&quot;)[0].substring(0, 5)&#10;        } catch (e: Exception) {&#10;            &quot;N/A&quot;&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Data class for recent visitor UI display&#10; * Only contains fields needed for dashboard display&#10; */&#10;data class RecentVisitor(&#10;    val name: String,&#10;    val purpose: String,&#10;    val time: String, // Formatted time string&#10;    val status: String // PENDING, APPROVED, REJECTED, EXPIRED&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.permitely.ui.host&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.permitely.data.models.DashboardStatsUiState&#10;import com.example.permitely.data.repository.DashboardRepository&#10;import com.example.permitely.data.repository.VisitorRepository&#10;import com.example.permitely.data.storage.TokenStorage&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for Host Dashboard Screen&#10; * Manages dashboard statistics and UI state&#10; */&#10;@HiltViewModel&#10;class HostDashboardViewModel @Inject constructor(&#10;    private val dashboardRepository: DashboardRepository,&#10;    private val visitorRepository: VisitorRepository,&#10;    private val tokenStorage: TokenStorage&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(DashboardStatsUiState())&#10;    val uiState: StateFlow&lt;DashboardStatsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Recent visitors state&#10;    private val _recentVisitors = MutableStateFlow&lt;List&lt;RecentVisitor&gt;&gt;(emptyList())&#10;    val recentVisitors: StateFlow&lt;List&lt;RecentVisitor&gt;&gt; = _recentVisitors.asStateFlow()&#10;&#10;    private val _isLoadingVisitors = MutableStateFlow(false)&#10;    val isLoadingVisitors: StateFlow&lt;Boolean&gt; = _isLoadingVisitors.asStateFlow()&#10;&#10;    init {&#10;        loadDashboardData()&#10;        loadRecentVisitors()&#10;    }&#10;&#10;    /**&#10;     * Load dashboard statistics and user info from the API and storage&#10;     */&#10;    private fun loadDashboardData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            // Load user name from profile API (fresh data)&#10;            dashboardRepository.getUserName().collect { nameResult -&gt;&#10;                nameResult.fold(&#10;                    onSuccess = { userName -&gt;&#10;                        _uiState.value = _uiState.value.copy(userName = userName)&#10;                    },&#10;                    onFailure = { /* Keep existing name or use default */ }&#10;                )&#10;            }&#10;        }&#10;&#10;        // Load dashboard stats separately&#10;        loadDashboardStats()&#10;    }&#10;&#10;    /**&#10;     * Load dashboard statistics from the API&#10;     */&#10;    private fun loadDashboardStats() {&#10;        viewModelScope.launch {&#10;            dashboardRepository.getDashboardStats().collect { result -&gt;&#10;                result.fold(&#10;                    onSuccess = { stats -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            totalVisitors = stats.totalVisitors,&#10;                            approved = stats.approved,&#10;                            pending = stats.pending,&#10;                            rejected = stats.rejected,&#10;                            expired = stats.expired,&#10;                            isLoading = false,&#10;                            error = null&#10;                        )&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isLoading = false,&#10;                            error = exception.message ?: &quot;Unknown error occurred&quot;&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load recent visitors from the API&#10;     */&#10;    private fun loadRecentVisitors() {&#10;        viewModelScope.launch {&#10;            _isLoadingVisitors.value = true&#10;            visitorRepository.getRecentVisitors().collect { result -&gt;&#10;                result.fold(&#10;                    onSuccess = { visitors -&gt;&#10;                        // Convert API visitors to UI visitors (only need name, purpose, time, status)&#10;                        val recentVisitors = visitors.map { apiVisitor -&gt;&#10;                            RecentVisitor(&#10;                                name = apiVisitor.name,&#10;                                purpose = apiVisitor.purposeOfVisit,&#10;                                time = formatTime(apiVisitor.createdAt),&#10;                                status = apiVisitor.status&#10;                            )&#10;                        }&#10;                        _recentVisitors.value = recentVisitors&#10;                        println(&quot;DEBUG: Loaded ${recentVisitors.size} recent visitors&quot;)&#10;                    },&#10;                    onFailure = { exception -&gt;&#10;                        println(&quot;DEBUG: Failed to load recent visitors: ${exception.message}&quot;)&#10;                        // Keep empty list on error&#10;                        _recentVisitors.value = emptyList()&#10;                    }&#10;                )&#10;                _isLoadingVisitors.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh recent visitors&#10;     */&#10;    fun refreshRecentVisitors() {&#10;        loadRecentVisitors()&#10;    }&#10;&#10;    /**&#10;     * Refresh dashboard statistics&#10;     */&#10;    fun refresh() {&#10;        loadDashboardData()&#10;        loadRecentVisitors()&#10;    }&#10;&#10;    /**&#10;     * Clear error state&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    /**&#10;     * Format timestamp to readable time&#10;     */&#10;    private fun formatTime(timestamp: String): String {&#10;        return try {&#10;            // Extract time from ISO timestamp: &quot;2025-08-10T08:00:00Z&quot; -&gt; &quot;08:00&quot;&#10;            timestamp.split(&quot;T&quot;)[1].split(&quot;Z&quot;)[0].substring(0, 5)&#10;        } catch (e: Exception) {&#10;            &quot;N/A&quot;&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Data class for recent visitor UI display&#10; * Only contains fields needed for dashboard display&#10; */&#10;data class RecentVisitor(&#10;    val name: String,&#10;    val purpose: String,&#10;    val time: String, // Formatted time string&#10;    val status: String // PENDING, APPROVED, REJECTED, EXPIRED&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>